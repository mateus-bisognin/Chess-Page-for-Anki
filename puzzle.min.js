var LichessPuzzle = (function () {
  "use strict";
  const e = {
    createElement: function (e, t) {
      return document.createElement(e, t);
    },
    createElementNS: function (e, t, n) {
      return document.createElementNS(e, t, n);
    },
    createTextNode: function (e) {
      return document.createTextNode(e);
    },
    createComment: function (e) {
      return document.createComment(e);
    },
    insertBefore: function (e, t, n) {
      e.insertBefore(t, n);
    },
    removeChild: function (e, t) {
      e.removeChild(t);
    },
    appendChild: function (e, t) {
      e.appendChild(t);
    },
    parentNode: function (e) {
      return e.parentNode;
    },
    nextSibling: function (e) {
      return e.nextSibling;
    },
    tagName: function (e) {
      return e.tagName;
    },
    setTextContent: function (e, t) {
      e.textContent = t;
    },
    getTextContent: function (e) {
      return e.textContent;
    },
    isElement: function (e) {
      return 1 === e.nodeType;
    },
    isText: function (e) {
      return 3 === e.nodeType;
    },
    isComment: function (e) {
      return 8 === e.nodeType;
    },
  };
  function t(e, t, n, o, r) {
    return {
      sel: e,
      data: t,
      children: n,
      text: o,
      elm: r,
      key: void 0 === t ? void 0 : t.key,
    };
  }
  const n = Array.isArray;
  function o(e) {
    return "string" == typeof e || "number" == typeof e;
  }
  function r(e) {
    return void 0 === e;
  }
  function i(e) {
    return void 0 !== e;
  }
  const s = t("", {}, [], void 0, void 0);
  function a(e, t) {
    var n, o;
    const r = e.key === t.key,
      i =
        (null === (n = e.data) || void 0 === n ? void 0 : n.is) ===
        (null === (o = t.data) || void 0 === o ? void 0 : o.is);
    return e.sel === t.sel && r && i;
  }
  function c(e, t, n) {
    var o;
    const r = {};
    for (let i = t; i <= n; ++i) {
      const t = null === (o = e[i]) || void 0 === o ? void 0 : o.key;
      void 0 !== t && (r[t] = i);
    }
    return r;
  }
  const l = ["create", "update", "remove", "destroy", "pre", "post"];
  function u(e, t, n) {
    if (
      ((e.ns = "http://www.w3.org/2000/svg"),
      "foreignObject" !== n && void 0 !== t)
    )
      for (let o = 0; o < t.length; ++o) {
        const e = t[o].data;
        void 0 !== e && u(e, t[o].children, t[o].sel);
      }
  }
  function d(e, r, i) {
    let s,
      a,
      c,
      l = {};
    if (
      (void 0 !== i
        ? (null !== r && (l = r),
          n(i) ? (s = i) : o(i) ? (a = i) : i && i.sel && (s = [i]))
        : null != r &&
          (n(r) ? (s = r) : o(r) ? (a = r) : r && r.sel ? (s = [r]) : (l = r)),
      void 0 !== s)
    )
      for (c = 0; c < s.length; ++c)
        o(s[c]) && (s[c] = t(void 0, void 0, void 0, s[c], void 0));
    return (
      "s" !== e[0] ||
        "v" !== e[1] ||
        "g" !== e[2] ||
        (3 !== e.length && "." !== e[3] && "#" !== e[3]) ||
        u(l, s, e),
      t(e, l, s, a, void 0)
    );
  }
  function h(e, t) {
    let n;
    const o = t.elm;
    let r = e.data.attrs,
      i = t.data.attrs;
    if ((r || i) && r !== i) {
      for (n in ((r = r || {}), (i = i || {}), i)) {
        const e = i[n];
        r[n] !== e &&
          (!0 === e
            ? o.setAttribute(n, "")
            : !1 === e
            ? o.removeAttribute(n)
            : 120 !== n.charCodeAt(0)
            ? o.setAttribute(n, e)
            : 58 === n.charCodeAt(3)
            ? o.setAttributeNS("http://www.w3.org/XML/1998/namespace", n, e)
            : 58 === n.charCodeAt(5)
            ? o.setAttributeNS("http://www.w3.org/1999/xlink", n, e)
            : o.setAttribute(n, e));
      }
      for (n in r) n in i || o.removeAttribute(n);
    }
  }
  const p = { create: h, update: h };
  function f(e, t) {
    let n, o;
    const r = t.elm;
    let i = e.data.class,
      s = t.data.class;
    if ((i || s) && i !== s) {
      for (o in ((i = i || {}), (s = s || {}), i))
        i[o] &&
          !Object.prototype.hasOwnProperty.call(s, o) &&
          r.classList.remove(o);
      for (o in s)
        (n = s[o]), n !== i[o] && r.classList[n ? "add" : "remove"](o);
    }
  }
  const m = { create: f, update: f };
  function v(e) {
    !window.LichessSpeech && e
      ? lichess.loadModule("speech")
      : window.LichessSpeech && !e && (window.LichessSpeech = void 0);
  }
  function g(e, t) {
    var n;
    (n = (n) => n.step(e, t)), window.LichessSpeech && n(window.LichessSpeech);
  }
  const b = (e) => void 0 !== e,
    k = (e) => null != e,
    w = (e) => {
      let t = e;
      return function (e) {
        return b(e) && (t = e), t;
      };
    },
    y = { Accept: "application/vnd.lichess.v5+json" },
    z = { cache: "no-cache", credentials: "same-origin" },
    S = { "X-Requested-With": "XMLHttpRequest" },
    C = (e) => {
      if (e.ok) return e;
      if (429 == e.status) throw new Error("Too many requests");
      if (413 == e.status) throw new Error("The uploaded file is too large");
      throw new Error(`Error ${e.status}`);
    },
    x = (e, t = {}) =>
      fetch(e, { ...z, headers: { ...y, ...S }, ...t }).then((e) =>
        C(e).json()
      ),
    E = (e, t = {}) => M(e, t).then((e) => C(e).text()),
    M = (e, t = {}) => fetch(e, { ...z, headers: { ...S }, ...t }),
    _ = (e) => {
      const t = new FormData();
      for (const n of Object.keys(e)) t.append(n, e[n]);
      return t;
    };
  function P(e, t) {
    return (function (e) {
      let t, n;
      return function (...o) {
        const r = this,
          i = () => {
            (n = void 0),
              (t = e.apply(r, o).finally(() => {
                (t = void 0), n && n();
              }));
          };
        t ? (n = i) : i();
      };
    })(function (...n) {
      return t.apply(this, n), new Promise((t) => setTimeout(t, e));
    });
  }
  function q(e, t, n) {
    return x(`/training/${e}/vote/${t}`, {
      method: "POST",
      body: b(n) ? _({ vote: n }) : void 0,
    });
  }
  const A = P(1e3, (e) =>
    E("/pref/zen", { method: "post", body: _({ zen: e ? 1 : 0 }) })
  );
  function O(e) {
    const t = { sync: void 0, promise: e.then((e) => ((t.sync = e), e)) };
    return t;
  }
  const R = ["a", "b", "c", "d", "e", "f", "g", "h"],
    N = ["1", "2", "3", "4", "5", "6", "7", "8"],
    D = ["white", "black"],
    T = ["pawn", "knight", "bishop", "rook", "queen", "king"],
    I = ["a", "h"];
  function L(e) {
    if (!e) return false;

    return "role" in e;
  }
  function B(e) {
    return void 0 !== e;
  }
  function K(e) {
    return "white" === e ? "black" : "white";
  }
  function F(e) {
    return e >> 3;
  }
  function V(e) {
    return 7 & e;
  }
  function W(e) {
    switch (e) {
      case "pawn":
        return "p";
      case "knight":
        return "n";
      case "bishop":
        return "b";
      case "rook":
        return "r";
      case "queen":
        return "q";
      case "king":
        return "k";
    }
  }
  function j(e) {
    switch (e) {
      case "P":
      case "p":
        return "pawn";
      case "N":
      case "n":
        return "knight";
      case "B":
      case "b":
        return "bishop";
      case "R":
      case "r":
        return "rook";
      case "Q":
      case "q":
        return "queen";
      case "K":
      case "k":
        return "king";
      default:
        return;
    }
  }
  function U(e) {
    if (2 !== e.length) return;
    const t = e.charCodeAt(0) - "a".charCodeAt(0),
      n = e.charCodeAt(1) - "1".charCodeAt(0);
    return t < 0 || t >= 8 || n < 0 || n >= 8 ? void 0 : t + 8 * n;
  }
  function H(e) {
    return R[V(e)] + N[F(e)];
  }
  function G(e) {
    if ("@" === e[1] && 4 === e.length) {
      const t = j(e[0]),
        n = U(e.slice(2));
      if (t && B(n)) return { role: t, to: n };
    } else if (4 === e.length || 5 === e.length) {
      const t = U(e.slice(0, 2)),
        n = U(e.slice(2, 4));
      let o;
      if (5 === e.length && ((o = j(e[4])), !o)) return;
      if (B(t) && B(n)) return { from: t, to: n, promotion: o };
    }
  }
  function X(e) {
    return L(e)
      ? `${W(e.role).toUpperCase()}@${H(e.to)}`
      : H(e.from) + H(e.to) + (e.promotion ? W(e.promotion) : "");
  }
  function Q(e, t) {
    return "white" === e ? ("a" === t ? 2 : 6) : "a" === t ? 58 : 62;
  }
  function Y(e) {
    return L(e)
      ? String.fromCharCode(
          35 + e.to,
          139 + ["queen", "rook", "bishop", "knight", "pawn"].indexOf(e.role)
        )
      : String.fromCharCode(
          35 + e.from,
          e.promotion
            ? 99 +
                8 *
                  ["queen", "rook", "bishop", "knight", "king"].indexOf(
                    e.promotion
                  ) +
                V(e.to)
            : 35 + e.to
        );
  }
  function J(e) {
    switch (e) {
      case "standard":
      case "chess960":
      case "fromPosition":
        return "chess";
      case "threeCheck":
        return "3check";
      case "kingOfTheHill":
        return "kingofthehill";
      case "racingKings":
        return "racingkings";
      default:
        return e;
    }
  }
  function Z() {
    const e = {};
    return (
      (e.promise = new Promise((t, n) => {
        (e.resolve = t), (e.reject = n);
      })),
      e
    );
  }
  const ee = new RegExp(
    "" +
      /^info depth (\d+) seldepth \d+ multipv (\d+) /.source +
      /score (cp|mate) ([-\d]+) /.source +
      /(?:(upper|lower)bound )?nodes (\d+) nps \S+ /.source +
      /(?:hashfull \d+ )?(?:tbhits \d+ )?time (\S+) /.source +
      /pv (.+)/.source
  );
  class te {
    constructor(e, t) {
      (this.send = e),
        (this.opts = t),
        (this.engineNameDeferred = Z()),
        (this.engineName = O(this.engineNameDeferred.promise)),
        (this.options = new Map([
          ["Threads", 1],
          ["Hash", 16],
          ["MultiPV", 1],
          ["UCI_Variant", "chess"],
        ])),
        (this.expectedPvs = 1);
    }
    init() {
      this.send("uci"),
        this.setOption("UCI_AnalyseMode", "true"),
        this.setOption("Analysis Contempt", "Off"),
        this.setOption("UCI_Chess960", "true");
    }
    setOption(e, t) {
      this.options.get(e) !== t &&
        (this.send(`setoption name ${e} value ${t}`), this.options.set(e, t));
    }
    received(e) {
      if (e.startsWith("id name "))
        this.engineNameDeferred.resolve(e.substring("id name ".length));
      else if (e.startsWith("bestmove "))
        return (
          this.work && this.currentEval && this.work.emit(this.currentEval),
          (this.work = void 0),
          void this.swapWork()
        );
      if (!this.work || this.work.stopRequested) return;
      const t = e.match(ee);
      if (!t) return;
      const n = parseInt(t[1]),
        o = parseInt(t[2]),
        r = "mate" === t[3],
        i = parseInt(t[4]),
        s = t[5],
        a = parseInt(t[6]),
        c = parseInt(t[7]),
        l = t[8].split(" ");
      if (r && !i) return;
      if ((this.expectedPvs < o && (this.expectedPvs = o), n < 6)) return;
      const u = this.work.threatMode ? 0 : 1,
        d = this.work.ply % 2 === u ? -i : i;
      if (s && 1 === o) return;
      const h = {
        moves: l,
        cp: r ? void 0 : d,
        mate: r ? d : void 0,
        depth: n,
      };
      1 === o
        ? (this.currentEval = {
            fen: this.work.currentFen,
            maxDepth: this.work.maxDepth,
            depth: n,
            knps: a / c,
            nodes: a,
            cp: r ? void 0 : d,
            mate: r ? d : void 0,
            pvs: [h],
            millis: c,
          })
        : this.currentEval &&
          (this.currentEval.pvs.push(h),
          (this.currentEval.depth = Math.min(this.currentEval.depth, n))),
        o === this.expectedPvs &&
          this.currentEval &&
          (this.work.emit(this.currentEval),
          n >= this.work.maxDepth &&
            c > 8e3 &&
            a > 4e3 * Math.exp(0.3 * this.work.maxDepth) &&
            this.stop());
    }
    swapWork() {
      this.stop(),
        this.work ||
          ((this.work = this.nextWork),
          (this.nextWork = void 0),
          this.work &&
            ((this.currentEval = void 0),
            (this.expectedPvs = 1),
            this.setOption(
              "UCI_Variant",
              "antichess" === this.opts.variant
                ? "giveaway"
                : J(this.opts.variant)
            ),
            this.setOption(
              "Threads",
              this.opts.threads ? this.opts.threads() : 1
            ),
            this.setOption(
              "Hash",
              this.opts.hashSize ? this.opts.hashSize() : 16
            ),
            this.setOption("MultiPV", this.work.multiPv),
            this.send(
              [
                "position fen",
                this.work.initialFen,
                "moves",
                ...this.work.moves,
              ].join(" ")
            ),
            this.send(
              this.work.maxDepth >= 99 ? "go depth 245" : "go movetime 90000"
            )));
    }
    start(e) {
      (this.nextWork = e), this.swapWork();
    }
    stop() {
      this.work &&
        !this.work.stopRequested &&
        ((this.work.stopRequested = !0), this.send("stop"));
    }
    isComputing() {
      return !!this.work && !this.work.stopRequested;
    }
  }
  class ne {
    constructor(e, t) {
      (this.protocolOpts = e),
        (this.opts = t),
        (this.isComputing = () =>
          !!this.protocol.sync && this.protocol.sync.isComputing()),
        (this.engineName = () => {
          var e;
          return null === (e = this.protocol.sync) || void 0 === e
            ? void 0
            : e.engineName.sync;
        }),
        (this.protocol = O(this.boot()));
    }
    stop() {
      return this.protocol.promise.then((e) => e.stop());
    }
    start(e) {
      return this.protocol.promise.then((t) => t.start(e));
    }
  }
  class oe extends ne {
    boot() {
      this.worker = new Worker(
        lichess.assetUrl(this.opts.url, { sameDomain: !0 })
      );
      const e = new te(this.send.bind(this), this.protocolOpts);
      return (
        this.worker.addEventListener(
          "message",
          (t) => {
            e.received(t.data);
          },
          !0
        ),
        e.init(),
        Promise.resolve(e)
      );
    }
    destroy() {
      this.worker.terminate();
    }
    send(e) {
      this.worker.postMessage(e);
    }
  }
  class re extends ne {
    async boot() {
      let e = re.protocols[this.opts.module];
      if (!e) {
        const t = this.opts.version,
          n = this.opts.cache;
        let o;
        if (n) {
          const e = this.opts.baseUrl + "stockfish.wasm";
          if (n)
            try {
              const [r, i] = await n.get(e, t);
              r && (o = i);
            } catch (Ce) {
              console.log("ceval: idb cache load failed:", Ce);
            }
          o ||
            (o = await new Promise((n, o) => {
              const r = new XMLHttpRequest();
              r.open("GET", lichess.assetUrl(e, { version: t }), !0),
                (r.responseType = "arraybuffer"),
                (r.onerror = (e) => o(e)),
                (r.onprogress = (e) => {
                  var t, n;
                  return null === (n = (t = this.opts).downloadProgress) ||
                    void 0 === n
                    ? void 0
                    : n.call(t, e.loaded);
                }),
                (r.onload = (e) => {
                  var t, o;
                  null === (o = (t = this.opts).downloadProgress) ||
                    void 0 === o ||
                    o.call(t, 0),
                    n(r.response);
                }),
                r.send();
            }));
          try {
            await n.set(e, t, o);
          } catch (Ce) {
            console.log("ceval: idb cache store failed:", Ce);
          }
        }
        await lichess.loadScript(this.opts.baseUrl + "stockfish.js", {
          version: t,
        });
        const r = await window[this.opts.module]({
          wasmBinary: o,
          locateFile: (e) =>
            lichess.assetUrl(this.opts.baseUrl + e, {
              version: t,
              sameDomain: e.endsWith(".worker.js"),
            }),
          wasmMemory: this.opts.wasmMemory,
        });
        (re.sf[this.opts.module] = r),
          (e = new te(this.send.bind(this), this.protocolOpts)),
          r.addMessageListener(e.received.bind(e)),
          e.init(),
          (re.protocols[this.opts.module] = e);
      }
      return e;
    }
    destroy() {
      var e;
      null === (e = this.protocol.sync) || void 0 === e || e.stop();
    }
    send(e) {
      var t;
      null === (t = re.sf[this.opts.module]) ||
        void 0 === t ||
        t.postMessage(e);
    }
  }
  (re.protocols = {}), (re.sf = {});
  const ie = lichess.storage;
  function se(e, t) {
    const n = "analyse." + e,
      o = !0 === t || !1 === t;
    let r;
    return function (e) {
      return (
        b(e) && e != r
          ? ((r = e + ""), ie.set(n, e))
          : b(r) || ((r = ie.get(n)), null === r && (r = t + "")),
        o ? "true" === r : r
      );
    };
  }
  const ae = (e, t) => (n) => {
    if (b(n)) return ie.set(e, JSON.stringify(n)), n;
    const o = JSON.parse(ie.get(e));
    return null !== o ? o : t();
  };
  function ce(e) {
    return 2 / (1 + Math.exp(-0.004 * e)) - 1;
  }
  function le(e) {
    return void 0 !== e.mate
      ? ((n = e.mate),
        ce(100 * (21 - Math.min(10, Math.abs(n))) * (n > 0 ? 1 : -1)))
      : ((t = e.cp), ce(Math.min(Math.max(-1e3, t), 1e3)));
    var t, n;
  }
  function ue(e, t) {
    return (function (e, t) {
      return "white" === e ? t : -t;
    })(e, le(t));
  }
  function de(e, t, n) {
    return (ue(e, t) - ue(e, n)) / 2;
  }
  function he(e) {
    return (
      ((e = Math.max(Math.min(Math.round(e / 10) / 10, 99), -99)) > 0
        ? "+"
        : "") + e.toFixed(1)
    );
  }
  function pe(e) {
    return new Promise((t, n) => {
      (e.oncomplete = e.onsuccess = () => t(e.result)),
        (e.onabort = e.onerror = () => n(e.error));
    });
  }
  function fe(e, t) {
    const n = indexedDB.open(e);
    n.onupgradeneeded = () => n.result.createObjectStore(t);
    const o = pe(n);
    return (e, n) => o.then((o) => n(o.transaction(t, e).objectStore(t)));
  }
  let me;
  function ve() {
    return me || (me = fe("keyval-store", "keyval")), me;
  }
  function ge(e, t = ve()) {
    return t("readonly", (t) => pe(t.get(e)));
  }
  function be(e, t, n = ve()) {
    return n("readwrite", (n) => (n.put(t, e), pe(n.transaction)));
  }
  class ke {
    constructor(e) {
      this.store = fe(`${e}--db`, `${e}--store`);
    }
    async get(e, t) {
      if ((await ge(`${e}--version`, this.store)) !== t) return [!1, void 0];
      return [!0, await ge(`${e}--data`, this.store)];
    }
    async set(e, t, n) {
      (await ge(`${e}--version`, this.store)) !== t &&
        (await (function (e, t = ve()) {
          return t("readwrite", (t) => (t.delete(e), pe(t.transaction)));
        })(`${e}--version`, this.store),
        await be(`${e}--data`, n, this.store),
        await be(`${e}--version`, t, this.store));
    }
  }
  function we(e, t) {
    (e.prototype = Object.create(t.prototype)),
      (e.prototype.constructor = e),
      (e.__proto__ = t);
  }
  var ye,
    ze = (function () {
      function e() {}
      var t = e.prototype;
      return (
        (t.unwrap = function (e, t) {
          var n = this._chain(
            function (t) {
              return ye.ok(e ? e(t) : t);
            },
            function (e) {
              return t ? ye.ok(t(e)) : ye.err(e);
            }
          );
          if (n.isErr) throw n.error;
          return n.value;
        }),
        (t.map = function (e, t) {
          return this._chain(
            function (t) {
              return ye.ok(e(t));
            },
            function (e) {
              return ye.err(t ? t(e) : e);
            }
          );
        }),
        (t.chain = function (e, t) {
          return this._chain(
            e,
            t ||
              function (e) {
                return ye.err(e);
              }
          );
        }),
        e
      );
    })(),
    Se = (function (e) {
      function t(t) {
        var n;
        return (
          ((n = e.call(this) || this).value = t),
          (n.isOk = !0),
          (n.isErr = !1),
          n
        );
      }
      return (
        we(t, e),
        (t.prototype._chain = function (e, t) {
          return e(this.value);
        }),
        t
      );
    })(ze),
    Ce = (function (e) {
      function t(t) {
        var n;
        return (
          ((n = e.call(this) || this).error = t),
          (n.isOk = !1),
          (n.isErr = !0),
          n
        );
      }
      return (
        we(t, e),
        (t.prototype._chain = function (e, t) {
          return t(this.error);
        }),
        t
      );
    })(ze);
  function xe(e) {
    return (
      (e =
        (858993459 & (e -= (e >>> 1) & 1431655765)) + ((e >>> 2) & 858993459)),
      Math.imul((e + (e >>> 4)) & 252645135, 16843009) >> 24
    );
  }
  function Ee(e) {
    return (
      (((e = ((e >>> 8) & 16711935) | ((16711935 & e) << 8)) >>> 16) & 65535) |
      ((65535 & e) << 16)
    );
  }
  function Me(e) {
    return Ee(
      (e =
        (((e =
          (((e = ((e >>> 1) & 1431655765) | ((1431655765 & e) << 1)) >>> 2) &
            858993459) |
          ((858993459 & e) << 2)) >>>
          4) &
          252645135) |
        ((252645135 & e) << 4))
    );
  }
  !(function (e) {
    (e.ok = function (e) {
      return new Se(e);
    }),
      (e.err = function (e) {
        return new Ce(e || new Error());
      }),
      (e.all = function (t) {
        if (Array.isArray(t)) {
          for (var n = [], o = 0; o < t.length; o++) {
            var r = t[o];
            if (r.isErr) return r;
            n.push(r.value);
          }
          return e.ok(n);
        }
        for (var i = {}, s = Object.keys(t), a = 0; a < s.length; a++) {
          var c = t[s[a]];
          if (c.isErr) return c;
          i[s[a]] = c.value;
        }
        return e.ok(i);
      });
  })(ye || (ye = {}));
  class _e {
    constructor(e, t) {
      (this.lo = e), (this.hi = t), (this.lo = 0 | e), (this.hi = 0 | t);
    }
    static fromSquare(e) {
      return e >= 32 ? new _e(0, 1 << (e - 32)) : new _e(1 << e, 0);
    }
    static fromRank(e) {
      return new _e(255, 0).shl64(8 * e);
    }
    static fromFile(e) {
      return new _e(16843009 << e, 16843009 << e);
    }
    static empty() {
      return new _e(0, 0);
    }
    static full() {
      return new _e(4294967295, 4294967295);
    }
    static corners() {
      return new _e(129, 2164260864);
    }
    static center() {
      return new _e(402653184, 24);
    }
    static backranks() {
      return new _e(255, 4278190080);
    }
    static backrank(e) {
      return "white" === e ? new _e(255, 0) : new _e(0, 4278190080);
    }
    static lightSquares() {
      return new _e(1437226410, 1437226410);
    }
    static darkSquares() {
      return new _e(2857740885, 2857740885);
    }
    complement() {
      return new _e(~this.lo, ~this.hi);
    }
    xor(e) {
      return new _e(this.lo ^ e.lo, this.hi ^ e.hi);
    }
    union(e) {
      return new _e(this.lo | e.lo, this.hi | e.hi);
    }
    intersect(e) {
      return new _e(this.lo & e.lo, this.hi & e.hi);
    }
    diff(e) {
      return new _e(this.lo & ~e.lo, this.hi & ~e.hi);
    }
    intersects(e) {
      return this.intersect(e).nonEmpty();
    }
    isDisjoint(e) {
      return this.intersect(e).isEmpty();
    }
    supersetOf(e) {
      return e.diff(this).isEmpty();
    }
    subsetOf(e) {
      return this.diff(e).isEmpty();
    }
    shr64(e) {
      return e >= 64
        ? _e.empty()
        : e >= 32
        ? new _e(this.hi >>> (e - 32), 0)
        : e > 0
        ? new _e((this.lo >>> e) ^ (this.hi << (32 - e)), this.hi >>> e)
        : this;
    }
    shl64(e) {
      return e >= 64
        ? _e.empty()
        : e >= 32
        ? new _e(0, this.lo << (e - 32))
        : e > 0
        ? new _e(this.lo << e, (this.hi << e) ^ (this.lo >>> (32 - e)))
        : this;
    }
    bswap64() {
      return new _e(Ee(this.hi), Ee(this.lo));
    }
    rbit64() {
      return new _e(Me(this.hi), Me(this.lo));
    }
    minus64(e) {
      const t = this.lo - e.lo,
        n = ((t & e.lo & 1) + (e.lo >>> 1) + (t >>> 1)) >>> 31;
      return new _e(t, this.hi - (e.hi + n));
    }
    equals(e) {
      return this.lo === e.lo && this.hi === e.hi;
    }
    size() {
      return xe(this.lo) + xe(this.hi);
    }
    isEmpty() {
      return 0 === this.lo && 0 === this.hi;
    }
    nonEmpty() {
      return 0 !== this.lo || 0 !== this.hi;
    }
    has(e) {
      return 0 != (e >= 32 ? this.hi & (1 << (e - 32)) : this.lo & (1 << e));
    }
    set(e, t) {
      return t ? this.with(e) : this.without(e);
    }
    with(e) {
      return e >= 32
        ? new _e(this.lo, this.hi | (1 << (e - 32)))
        : new _e(this.lo | (1 << e), this.hi);
    }
    without(e) {
      return e >= 32
        ? new _e(this.lo, this.hi & ~(1 << (e - 32)))
        : new _e(this.lo & ~(1 << e), this.hi);
    }
    toggle(e) {
      return e >= 32
        ? new _e(this.lo, this.hi ^ (1 << (e - 32)))
        : new _e(this.lo ^ (1 << e), this.hi);
    }
    last() {
      return 0 !== this.hi
        ? 63 - Math.clz32(this.hi)
        : 0 !== this.lo
        ? 31 - Math.clz32(this.lo)
        : void 0;
    }
    first() {
      return 0 !== this.lo
        ? 31 - Math.clz32(this.lo & -this.lo)
        : 0 !== this.hi
        ? 63 - Math.clz32(this.hi & -this.hi)
        : void 0;
    }
    withoutFirst() {
      return 0 !== this.lo
        ? new _e(this.lo & (this.lo - 1), this.hi)
        : new _e(0, this.hi & (this.hi - 1));
    }
    moreThanOne() {
      return (
        (0 !== this.hi && 0 !== this.lo) ||
        0 != (this.lo & (this.lo - 1)) ||
        0 != (this.hi & (this.hi - 1))
      );
    }
    singleSquare() {
      return this.moreThanOne() ? void 0 : this.last();
    }
    isSingleSquare() {
      return this.nonEmpty() && !this.moreThanOne();
    }
    *[Symbol.iterator]() {
      let e = this.lo,
        t = this.hi;
      for (; 0 !== e; ) {
        const t = 31 - Math.clz32(e & -e);
        (e ^= 1 << t), yield t;
      }
      for (; 0 !== t; ) {
        const e = 31 - Math.clz32(t & -t);
        (t ^= 1 << e), yield 32 + e;
      }
    }
    *reversed() {
      let e = this.lo,
        t = this.hi;
      for (; 0 !== t; ) {
        const e = 31 - Math.clz32(t);
        (t ^= 1 << e), yield 32 + e;
      }
      for (; 0 !== e; ) {
        const t = 31 - Math.clz32(e);
        (e ^= 1 << t), yield t;
      }
    }
  }
  class Pe {
    constructor() {}
    static default() {
      const e = new Pe();
      return e.reset(), e;
    }
    static racingKings() {
      const e = new Pe();
      return (
        (e.occupied = new _e(65535, 0)),
        (e.promoted = _e.empty()),
        (e.white = new _e(61680, 0)),
        (e.black = new _e(3855, 0)),
        (e.pawn = _e.empty()),
        (e.knight = new _e(6168, 0)),
        (e.bishop = new _e(9252, 0)),
        (e.rook = new _e(16962, 0)),
        (e.queen = new _e(129, 0)),
        (e.king = new _e(33024, 0)),
        e
      );
    }
    static horde() {
      const e = new Pe();
      return (
        (e.occupied = new _e(4294967295, 4294901862)),
        (e.promoted = _e.empty()),
        (e.white = new _e(4294967295, 102)),
        (e.black = new _e(0, 4294901760)),
        (e.pawn = new _e(4294967295, 16711782)),
        (e.knight = new _e(0, 1107296256)),
        (e.bishop = new _e(0, 603979776)),
        (e.rook = new _e(0, 2164260864)),
        (e.queen = new _e(0, 134217728)),
        (e.king = new _e(0, 268435456)),
        e
      );
    }
    reset() {
      (this.occupied = new _e(65535, 4294901760)),
        (this.promoted = _e.empty()),
        (this.white = new _e(65535, 0)),
        (this.black = new _e(0, 4294901760)),
        (this.pawn = new _e(65280, 16711680)),
        (this.knight = new _e(66, 1107296256)),
        (this.bishop = new _e(36, 603979776)),
        (this.rook = new _e(129, 2164260864)),
        (this.queen = new _e(8, 134217728)),
        (this.king = new _e(16, 268435456));
    }
    static empty() {
      const e = new Pe();
      return e.clear(), e;
    }
    clear() {
      (this.occupied = _e.empty()), (this.promoted = _e.empty());
      for (const e of D) this[e] = _e.empty();
      for (const e of T) this[e] = _e.empty();
    }
    clone() {
      const e = new Pe();
      (e.occupied = this.occupied), (e.promoted = this.promoted);
      for (const t of D) e[t] = this[t];
      for (const t of T) e[t] = this[t];
      return e;
    }
    equalsIgnorePromoted(e) {
      return (
        !!this.white.equals(e.white) && T.every((t) => this[t].equals(e[t]))
      );
    }
    equals(e) {
      return this.equalsIgnorePromoted(e) && this.promoted.equals(e.promoted);
    }
    getColor(e) {
      return this.white.has(e) ? "white" : this.black.has(e) ? "black" : void 0;
    }
    getRole(e) {
      for (const t of T) if (this[t].has(e)) return t;
    }
    get(e) {
      const t = this.getColor(e);
      if (!t) return;
      return {
        color: t,
        role: this.getRole(e),
        promoted: this.promoted.has(e),
      };
    }
    take(e) {
      const t = this.get(e);
      return (
        t &&
          ((this.occupied = this.occupied.without(e)),
          (this[t.color] = this[t.color].without(e)),
          (this[t.role] = this[t.role].without(e)),
          t.promoted && (this.promoted = this.promoted.without(e))),
        t
      );
    }
    set(e, t) {
      const n = this.take(e);
      return (
        (this.occupied = this.occupied.with(e)),
        (this[t.color] = this[t.color].with(e)),
        (this[t.role] = this[t.role].with(e)),
        t.promoted && (this.promoted = this.promoted.with(e)),
        n
      );
    }
    has(e) {
      return this.occupied.has(e);
    }
    *[Symbol.iterator]() {
      for (const e of this.occupied) yield [e, this.get(e)];
    }
    pieces(e, t) {
      return this[e].intersect(this[t]);
    }
    rooksAndQueens() {
      return this.rook.union(this.queen);
    }
    bishopsAndQueens() {
      return this.bishop.union(this.queen);
    }
    kingOf(e) {
      return this.king.intersect(this[e]).diff(this.promoted).singleSquare();
    }
  }
  class qe {
    constructor() {}
    static empty() {
      const e = new qe();
      for (const t of T) e[t] = 0;
      return e;
    }
    static fromBoard(e, t) {
      const n = new qe();
      for (const o of T) n[o] = e.pieces(t, o).size();
      return n;
    }
    clone() {
      const e = new qe();
      for (const t of T) e[t] = this[t];
      return e;
    }
    equals(e) {
      return T.every((t) => this[t] === e[t]);
    }
    add(e) {
      const t = new qe();
      for (const n of T) t[n] = this[n] + e[n];
      return t;
    }
    nonEmpty() {
      return T.some((e) => this[e] > 0);
    }
    isEmpty() {
      return !this.nonEmpty();
    }
    hasPawns() {
      return this.pawn > 0;
    }
    hasNonPawns() {
      return (
        this.knight > 0 ||
        this.bishop > 0 ||
        this.rook > 0 ||
        this.queen > 0 ||
        this.king > 0
      );
    }
    count() {
      return (
        this.pawn +
        this.knight +
        this.bishop +
        this.rook +
        this.queen +
        this.king
      );
    }
  }
  class Ae {
    constructor(e, t) {
      (this.white = e), (this.black = t);
    }
    static empty() {
      return new Ae(qe.empty(), qe.empty());
    }
    static fromBoard(e) {
      return new Ae(qe.fromBoard(e, "white"), qe.fromBoard(e, "black"));
    }
    clone() {
      return new Ae(this.white.clone(), this.black.clone());
    }
    equals(e) {
      return this.white.equals(e.white) && this.black.equals(e.black);
    }
    add(e) {
      return new Ae(this.white.add(e.white), this.black.add(e.black));
    }
    count() {
      return this.white.count() + this.black.count();
    }
    isEmpty() {
      return this.white.isEmpty() && this.black.isEmpty();
    }
    nonEmpty() {
      return !this.isEmpty();
    }
    hasPawns() {
      return this.white.hasPawns() || this.black.hasPawns();
    }
    hasNonPawns() {
      return this.white.hasNonPawns() || this.black.hasNonPawns();
    }
  }
  class Oe {
    constructor(e, t) {
      (this.white = e), (this.black = t);
    }
    static default() {
      return new Oe(3, 3);
    }
    clone() {
      return new Oe(this.white, this.black);
    }
    equals(e) {
      return this.white === e.white && this.black === e.black;
    }
  }
  var Re;
  !(function (e) {
    (e.Fen = "ERR_FEN"),
      (e.Board = "ERR_BOARD"),
      (e.Pockets = "ERR_POCKETS"),
      (e.Turn = "ERR_TURN"),
      (e.Castling = "ERR_CASTLING"),
      (e.EpSquare = "ERR_EP_SQUARE"),
      (e.RemainingChecks = "ERR_REMAINING_CHECKS"),
      (e.Halfmoves = "ERR_HALFMOVES"),
      (e.Fullmoves = "ERR_FULLMOVES");
  })(Re || (Re = {}));
  class Ne extends Error {}
  function De(e) {
    return /^\d{1,4}$/.test(e) ? parseInt(e, 10) : void 0;
  }
  function Te(e) {
    const t = j(e);
    return t && { role: t, color: e.toLowerCase() === e ? "black" : "white" };
  }
  function $e(e) {
    const t = Pe.empty();
    let n = 7,
      o = 0;
    for (let r = 0; r < e.length; r++) {
      const i = e[r];
      if ("/" === i && 8 === o) (o = 0), n--;
      else {
        const s = parseInt(i, 10);
        if (s > 0) o += s;
        else {
          if (o >= 8 || n < 0) return ye.err(new Ne(Re.Board));
          const s = o + 8 * n,
            a = Te(i);
          if (!a) return ye.err(new Ne(Re.Board));
          "~" === e[r + 1] && ((a.promoted = !0), r++), t.set(s, a), o++;
        }
      }
    }
    return 0 !== n || 8 !== o ? ye.err(new Ne(Re.Board)) : ye.ok(t);
  }
  function Ie(e) {
    if (e.length > 64) return ye.err(new Ne(Re.Pockets));
    const t = Ae.empty();
    for (const n of e) {
      const e = Te(n);
      if (!e) return ye.err(new Ne(Re.Pockets));
      t[e.color][e.role]++;
    }
    return ye.ok(t);
  }
  function Le(e) {
    const t = e.split("+");
    if (3 === t.length && "" === t[0]) {
      const e = De(t[1]),
        n = De(t[2]);
      return !B(e) || e > 3 || !B(n) || n > 3
        ? ye.err(new Ne(Re.RemainingChecks))
        : ye.ok(new Oe(3 - e, 3 - n));
    }
    if (2 === t.length) {
      const e = De(t[0]),
        n = De(t[1]);
      return !B(e) || e > 3 || !B(n) || n > 3
        ? ye.err(new Ne(Re.RemainingChecks))
        : ye.ok(new Oe(e, n));
    }
    return ye.err(new Ne(Re.RemainingChecks));
  }
  function Be(e) {
    const t = e.split(" "),
      n = t.shift();
    let o,
      r,
      i = ye.ok(void 0);
    if (n.endsWith("]")) {
      const e = n.indexOf("[");
      if (-1 === e) return ye.err(new Ne(Re.Fen));
      (o = $e(n.substr(0, e))), (i = Ie(n.substr(e + 1, n.length - 1 - e - 1)));
    } else {
      const e = (function (e, t, n) {
        let o = e.indexOf(t);
        for (; n-- > 0 && -1 !== o; ) o = e.indexOf(t, o + t.length);
        return o;
      })(n, "/", 7);
      -1 === e
        ? (o = $e(n))
        : ((o = $e(n.substr(0, e))), (i = Ie(n.substr(e + 1))));
    }
    const s = t.shift();
    if (B(s) && "w" !== s) {
      if ("b" !== s) return ye.err(new Ne(Re.Turn));
      r = "black";
    } else r = "white";
    return o.chain((e) => {
      const n = t.shift(),
        o = B(n)
          ? (function (e, t) {
              let n = _e.empty();
              if ("-" === t) return ye.ok(n);
              if (!/^[KQABCDEFGH]{0,2}[kqabcdefgh]{0,2}$/.test(t))
                return ye.err(new Ne(Re.Castling));
              for (const o of t) {
                const t = o.toLowerCase(),
                  r = o === t ? "black" : "white",
                  i = _e.backrank(r).intersect(e[r]);
                let s;
                s =
                  "q" === t
                    ? i
                    : "k" === t
                    ? i.reversed()
                    : _e
                        .fromSquare(t.charCodeAt(0) - "a".charCodeAt(0))
                        .intersect(i);
                for (const o of s) {
                  if (e.king.has(o) && !e.promoted.has(o)) break;
                  if (e.rook.has(o)) {
                    n = n.with(o);
                    break;
                  }
                }
              }
              return ye.ok(n);
            })(e, n)
          : ye.ok(_e.empty()),
        s = t.shift();
      let a;
      if (B(s) && "-" !== s && ((a = U(s)), !B(a)))
        return ye.err(new Ne(Re.EpSquare));
      let c,
        l = t.shift();
      B(l) && l.includes("+") && ((c = Le(l)), (l = t.shift()));
      const u = B(l) ? De(l) : 0;
      if (!B(u)) return ye.err(new Ne(Re.Halfmoves));
      const d = t.shift(),
        h = B(d) ? De(d) : 1;
      if (!B(h)) return ye.err(new Ne(Re.Fullmoves));
      const p = t.shift();
      let f = ye.ok(void 0);
      if (B(p)) {
        if (B(c)) return ye.err(new Ne(Re.RemainingChecks));
        f = Le(p);
      } else B(c) && (f = c);
      return t.length > 0
        ? ye.err(new Ne(Re.Fen))
        : i.chain((t) =>
            o.chain((n) =>
              f.map((o) => ({
                board: e,
                pockets: t,
                turn: r,
                unmovedRooks: n,
                remainingChecks: o,
                epSquare: a,
                halfmoves: u,
                fullmoves: Math.max(1, h),
              }))
            )
          );
    });
  }
  function Ke(e, t) {
    let n = W(e.role);
    return (
      "white" === e.color && (n = n.toUpperCase()),
      (null == t ? void 0 : t.promoted) && e.promoted && (n += "~"),
      n
    );
  }
  function Fe(e, t) {
    let n = "",
      o = 0;
    for (let r = 7; r >= 0; r--)
      for (let i = 0; i < 8; i++) {
        const s = i + 8 * r,
          a = e.get(s);
        a ? (o > 0 && ((n += o), (o = 0)), (n += Ke(a, t))) : o++,
          7 === i && (o > 0 && ((n += o), (o = 0)), 0 !== r && (n += "/"));
      }
    return n;
  }
  function Ve(e) {
    return T.map((t) => W(t).repeat(e[t])).join("");
  }
  function We(e, t, n) {
    const o = null == n ? void 0 : n.shredder;
    let r = "";
    for (const i of D) {
      const n = _e.backrank(i),
        s = e.kingOf(i);
      if (!B(s) || !n.has(s)) continue;
      const a = e.pieces(i, "rook").intersect(n);
      for (const e of t.intersect(a).reversed())
        if (!o && e === a.first() && e < s) r += "white" === i ? "Q" : "q";
        else if (!o && e === a.last() && s < e) r += "white" === i ? "K" : "k";
        else {
          const t = R[V(e)];
          r += "white" === i ? t.toUpperCase() : t;
        }
    }
    return r || "-";
  }
  function je(e, t) {
    return [
      Fe(e.board, t) +
        (e.pockets
          ? `[${((o = e.pockets), Ve(o.white).toUpperCase() + Ve(o.black))}]`
          : ""),
      e.turn[0],
      We(e.board, e.unmovedRooks, t),
      B(e.epSquare) ? H(e.epSquare) : "-",
      ...(e.remainingChecks
        ? [((n = e.remainingChecks), `${n.white}+${n.black}`)]
        : []),
      ...((null == t ? void 0 : t.epd)
        ? []
        : [
            Math.max(0, Math.min(e.halfmoves, 9999)),
            Math.max(1, Math.min(e.fullmoves, 9999)),
          ]),
    ].join(" ");
    var n, o;
  }
  function Ue(e, t) {
    let n = _e.empty();
    for (const o of t) {
      const t = e + o;
      0 <= t && t < 64 && Math.abs(V(e) - V(t)) <= 2 && (n = n.with(t));
    }
    return n;
  }
  function He(e) {
    const t = [];
    for (let n = 0; n < 64; n++) t[n] = e(n);
    return t;
  }
  const Ge = He((e) => Ue(e, [-9, -8, -7, -1, 1, 7, 8, 9])),
    Xe = He((e) => Ue(e, [-17, -15, -10, -6, 6, 10, 15, 17])),
    Qe = { white: He((e) => Ue(e, [7, 9])), black: He((e) => Ue(e, [-7, -9])) };
  function Ye(e) {
    return Ge[e];
  }
  function Je(e) {
    return Xe[e];
  }
  function Ze(e, t) {
    return Qe[e][t];
  }
  const et = He((e) => _e.fromFile(V(e)).without(e)),
    tt = He((e) => _e.fromRank(F(e)).without(e)),
    nt = He((e) => {
      const t = new _e(134480385, 2151686160),
        n = 8 * (F(e) - V(e));
      return (n >= 0 ? t.shl64(n) : t.shr64(-n)).without(e);
    }),
    ot = He((e) => {
      const t = new _e(270549120, 16909320),
        n = 8 * (F(e) + V(e) - 7);
      return (n >= 0 ? t.shl64(n) : t.shr64(-n)).without(e);
    });
  function rt(e, t, n) {
    let o = n.intersect(t),
      r = o.bswap64();
    return (
      (o = o.minus64(e)),
      (r = r.minus64(e.bswap64())),
      o.xor(r.bswap64()).intersect(t)
    );
  }
  function it(e, t) {
    const n = _e.fromSquare(e);
    return rt(n, nt[e], t).xor(rt(n, ot[e], t));
  }
  function st(e, t) {
    return (function (e, t) {
      return rt(_e.fromSquare(e), et[e], t);
    })(e, t).xor(
      (function (e, t) {
        const n = tt[e];
        let o = t.intersect(n),
          r = o.rbit64();
        return (
          (o = o.minus64(_e.fromSquare(e))),
          (r = r.minus64(_e.fromSquare(63 - e))),
          o.xor(r.rbit64()).intersect(n)
        );
      })(e, t)
    );
  }
  function at(e, t) {
    return it(e, t).xor(st(e, t));
  }
  function ct(e, t, n) {
    switch (e.role) {
      case "pawn":
        return Ze(e.color, t);
      case "knight":
        return Je(t);
      case "bishop":
        return it(t, n);
      case "rook":
        return st(t, n);
      case "queen":
        return at(t, n);
      case "king":
        return Ye(t);
    }
  }
  function lt(e, t) {
    const n = _e.fromSquare(t);
    return tt[e].intersects(n)
      ? tt[e].with(e)
      : ot[e].intersects(n)
      ? ot[e].with(e)
      : nt[e].intersects(n)
      ? nt[e].with(e)
      : et[e].intersects(n)
      ? et[e].with(e)
      : _e.empty();
  }
  function ut(e, t) {
    return lt(e, t)
      .intersect(_e.full().shl64(e).xor(_e.full().shl64(t)))
      .withoutFirst();
  }
  var dt;
  !(function (e) {
    (e.Empty = "ERR_EMPTY"),
      (e.OppositeCheck = "ERR_OPPOSITE_CHECK"),
      (e.ImpossibleCheck = "ERR_IMPOSSIBLE_CHECK"),
      (e.PawnsOnBackrank = "ERR_PAWNS_ON_BACKRANK"),
      (e.Kings = "ERR_KINGS"),
      (e.Variant = "ERR_VARIANT");
  })(dt || (dt = {}));
  class ht extends Error {}
  function pt(e, t) {
    return "white" === e ? ("a" === t ? 3 : 5) : "a" === t ? 59 : 61;
  }
  class ft {
    constructor() {}
    static default() {
      const e = new ft();
      return (
        (e.unmovedRooks = _e.corners()),
        (e.rook = { white: { a: 0, h: 7 }, black: { a: 56, h: 63 } }),
        (e.path = {
          white: { a: new _e(14, 0), h: new _e(96, 0) },
          black: { a: new _e(0, 234881024), h: new _e(0, 1610612736) },
        }),
        e
      );
    }
    static empty() {
      const e = new ft();
      return (
        (e.unmovedRooks = _e.empty()),
        (e.rook = {
          white: { a: void 0, h: void 0 },
          black: { a: void 0, h: void 0 },
        }),
        (e.path = {
          white: { a: _e.empty(), h: _e.empty() },
          black: { a: _e.empty(), h: _e.empty() },
        }),
        e
      );
    }
    clone() {
      const e = new ft();
      return (
        (e.unmovedRooks = this.unmovedRooks),
        (e.rook = {
          white: { a: this.rook.white.a, h: this.rook.white.h },
          black: { a: this.rook.black.a, h: this.rook.black.h },
        }),
        (e.path = {
          white: { a: this.path.white.a, h: this.path.white.h },
          black: { a: this.path.black.a, h: this.path.black.h },
        }),
        e
      );
    }
    add(e, t, n, o) {
      const r = Q(e, t),
        i = pt(e, t);
      (this.unmovedRooks = this.unmovedRooks.with(o)),
        (this.rook[e][t] = o),
        (this.path[e][t] = ut(o, i)
          .with(i)
          .union(ut(n, r).with(r))
          .without(n)
          .without(o));
    }
    static fromSetup(e) {
      const t = ft.empty(),
        n = e.unmovedRooks.intersect(e.board.rook);
      for (const o of D) {
        const r = _e.backrank(o),
          i = e.board.kingOf(o);
        if (!B(i) || !r.has(i)) continue;
        const s = n.intersect(e.board[o]).intersect(r),
          a = s.first();
        B(a) && a < i && t.add(o, "a", i, a);
        const c = s.last();
        B(c) && i < c && t.add(o, "h", i, c);
      }
      return t;
    }
    discardRook(e) {
      if (this.unmovedRooks.has(e)) {
        this.unmovedRooks = this.unmovedRooks.without(e);
        for (const t of D)
          for (const n of I)
            this.rook[t][n] === e && (this.rook[t][n] = void 0);
      }
    }
    discardSide(e) {
      (this.unmovedRooks = this.unmovedRooks.diff(_e.backrank(e))),
        (this.rook[e].a = void 0),
        (this.rook[e].h = void 0);
    }
  }
  class mt extends class {
    constructor(e) {
      this.rules = e;
    }
    kingAttackers(e, t, n) {
      return (function (e, t, n, o) {
        return n[t].intersect(
          st(e, o)
            .intersect(n.rooksAndQueens())
            .union(it(e, o).intersect(n.bishopsAndQueens()))
            .union(Je(e).intersect(n.knight))
            .union(Ye(e).intersect(n.king))
            .union(Ze(K(t), e).intersect(n.pawn))
        );
      })(e, t, this.board, n);
    }
    dropDests(e) {
      return _e.empty();
    }
    playCaptureAt(e, t) {
      (this.halfmoves = 0),
        "rook" === t.role && this.castles.discardRook(e),
        this.pockets && this.pockets[K(t.color)][t.role]++;
    }
    ctx() {
      const e = this.isVariantEnd(),
        t = this.board.kingOf(this.turn);
      if (!B(t))
        return {
          king: t,
          blockers: _e.empty(),
          checkers: _e.empty(),
          variantEnd: e,
          mustCapture: !1,
        };
      const n = st(t, _e.empty())
        .intersect(this.board.rooksAndQueens())
        .union(it(t, _e.empty()).intersect(this.board.bishopsAndQueens()))
        .intersect(this.board[K(this.turn)]);
      let o = _e.empty();
      for (const r of n) {
        const e = ut(t, r).intersect(this.board.occupied);
        e.moreThanOne() || (o = o.union(e));
      }
      return {
        king: t,
        blockers: o,
        checkers: this.kingAttackers(t, K(this.turn), this.board.occupied),
        variantEnd: e,
        mustCapture: !1,
      };
    }
    clone() {
      var e, t;
      const n = new this.constructor();
      return (
        (n.board = this.board.clone()),
        (n.pockets =
          null === (e = this.pockets) || void 0 === e ? void 0 : e.clone()),
        (n.turn = this.turn),
        (n.castles = this.castles.clone()),
        (n.epSquare = this.epSquare),
        (n.remainingChecks =
          null === (t = this.remainingChecks) || void 0 === t
            ? void 0
            : t.clone()),
        (n.halfmoves = this.halfmoves),
        (n.fullmoves = this.fullmoves),
        n
      );
    }
    equalsIgnoreMoves(e) {
      var t, n;
      return (
        this.rules === e.rules &&
        (this.pockets
          ? this.board.equals(e.board)
          : this.board.equalsIgnorePromoted(e.board)) &&
        ((e.pockets &&
          (null === (t = this.pockets) || void 0 === t
            ? void 0
            : t.equals(e.pockets))) ||
          (!this.pockets && !e.pockets)) &&
        this.turn === e.turn &&
        this.castles.unmovedRooks.equals(e.castles.unmovedRooks) &&
        this.legalEpSquare() === e.legalEpSquare() &&
        ((e.remainingChecks &&
          (null === (n = this.remainingChecks) || void 0 === n
            ? void 0
            : n.equals(e.remainingChecks))) ||
          (!this.remainingChecks && !e.remainingChecks))
      );
    }
    toSetup() {
      var e, t;
      return {
        board: this.board.clone(),
        pockets:
          null === (e = this.pockets) || void 0 === e ? void 0 : e.clone(),
        turn: this.turn,
        unmovedRooks: this.castles.unmovedRooks,
        epSquare: this.legalEpSquare(),
        remainingChecks:
          null === (t = this.remainingChecks) || void 0 === t
            ? void 0
            : t.clone(),
        halfmoves: Math.min(this.halfmoves, 150),
        fullmoves: Math.min(Math.max(this.fullmoves, 1), 9999),
      };
    }
    isInsufficientMaterial() {
      return D.every((e) => this.hasInsufficientMaterial(e));
    }
    hasDests(e) {
      e = e || this.ctx();
      for (const t of this.board[this.turn])
        if (this.dests(t, e).nonEmpty()) return !0;
      return this.dropDests(e).nonEmpty();
    }
    isLegal(e, t) {
      if (L(e))
        return (
          !(!this.pockets || this.pockets[this.turn][e.role] <= 0) &&
          ("pawn" !== e.role || !_e.backranks().has(e.to)) &&
          this.dropDests(t).has(e.to)
        );
      {
        if ("pawn" === e.promotion) return !1;
        if ("king" === e.promotion && "antichess" !== this.rules) return !1;
        if (
          !!e.promotion !==
          (this.board.pawn.has(e.from) && _e.backranks().has(e.to))
        )
          return !1;
        const n = this.dests(e.from, t);
        return n.has(e.to) || n.has(this.normalizeMove(e).to);
      }
    }
    isCheck() {
      const e = this.board.kingOf(this.turn);
      return (
        B(e) &&
        this.kingAttackers(e, K(this.turn), this.board.occupied).nonEmpty()
      );
    }
    isEnd(e) {
      return (
        !!(e ? e.variantEnd : this.isVariantEnd()) ||
        this.isInsufficientMaterial() ||
        !this.hasDests(e)
      );
    }
    isCheckmate(e) {
      return (
        !(e = e || this.ctx()).variantEnd &&
        e.checkers.nonEmpty() &&
        !this.hasDests(e)
      );
    }
    isStalemate(e) {
      return (
        !(e = e || this.ctx()).variantEnd &&
        e.checkers.isEmpty() &&
        !this.hasDests(e)
      );
    }
    outcome(e) {
      const t = this.variantOutcome(e);
      return (
        t ||
        ((e = e || this.ctx()),
        this.isCheckmate(e)
          ? { winner: K(this.turn) }
          : this.isInsufficientMaterial() || this.isStalemate(e)
          ? { winner: void 0 }
          : void 0)
      );
    }
    allDests(e) {
      e = e || this.ctx();
      const t = new Map();
      if (e.variantEnd) return t;
      for (const n of this.board[this.turn]) t.set(n, this.dests(n, e));
      return t;
    }
    castlingSide(e) {
      if (L(e)) return;
      if (!e) return;
      const t = e.to - e.from;
      return (2 === Math.abs(t) || this.board[this.turn].has(e.to)) &&
        this.board.king.has(e.from)
        ? t > 0
          ? "h"
          : "a"
        : void 0;
    }
    normalizeMove(e) {
      const t = this.castlingSide(e);
      if (!t) return e;
      const n = this.castles.rook[this.turn][t];
      return { from: e.from, to: B(n) ? n : e.to };
    }
    play(e) {
      const t = this.turn,
        n = this.epSquare,
        o = this.castlingSide(e);
      if (
        ((this.epSquare = void 0),
        (this.halfmoves += 1),
        "black" === t && (this.fullmoves += 1),
        (this.turn = K(t)),
        L(e))
      )
        this.board.set(e.to, { role: e.role, color: t }),
          this.pockets && this.pockets[t][e.role]--,
          "pawn" === e.role && (this.halfmoves = 0);
      else {
        if (!e) return;
        const r = this.board.take(e.from);
        if (!r) return;
        let i;
        if ("pawn" === r.role) {
          (this.halfmoves = 0),
            e.to === n &&
              (i = this.board.take(e.to + ("white" === t ? -8 : 8)));
          const o = e.from - e.to;
          16 === Math.abs(o) &&
            8 <= e.from &&
            e.from <= 55 &&
            (this.epSquare = (e.from + e.to) >> 1),
            e.promotion && ((r.role = e.promotion), (r.promoted = !0));
        } else if ("rook" === r.role) this.castles.discardRook(e.from);
        else if ("king" === r.role) {
          if (o) {
            const e = this.castles.rook[t][o];
            if (B(e)) {
              const n = this.board.take(e);
              this.board.set(Q(t, o), r), n && this.board.set(pt(t, o), n);
            }
          }
          if ((this.castles.discardSide(t), o)) return;
        }
        const s = this.board.set(e.to, r) || i;
        s && this.playCaptureAt(e.to, s);
      }
    }
    legalEpSquare(e) {
      if (!B(this.epSquare)) return;
      e = e || this.ctx();
      const t = this.board
        .pieces(this.turn, "pawn")
        .intersect(Ze(K(this.turn), this.epSquare));
      for (const n of t)
        if (this.dests(n, e).has(this.epSquare)) return this.epSquare;
    }
  } {
    constructor(e) {
      super(e || "chess");
    }
    static default() {
      const e = new this();
      return (
        (e.board = Pe.default()),
        (e.pockets = void 0),
        (e.turn = "white"),
        (e.castles = ft.default()),
        (e.epSquare = void 0),
        (e.remainingChecks = void 0),
        (e.halfmoves = 0),
        (e.fullmoves = 1),
        e
      );
    }
    static fromSetup(e) {
      const t = new this();
      return (
        (t.board = e.board.clone()),
        (t.pockets = void 0),
        (t.turn = e.turn),
        (t.castles = ft.fromSetup(e)),
        (t.epSquare = t.validEpSquare(e.epSquare)),
        (t.remainingChecks = void 0),
        (t.halfmoves = e.halfmoves),
        (t.fullmoves = e.fullmoves),
        t.validate().map((e) => t)
      );
    }
    clone() {
      return super.clone();
    }
    validate() {
      if (this.board.occupied.isEmpty()) return ye.err(new ht(dt.Empty));
      if (2 !== this.board.king.size()) return ye.err(new ht(dt.Kings));
      if (!B(this.board.kingOf(this.turn))) return ye.err(new ht(dt.Kings));
      const e = this.board.kingOf(K(this.turn));
      return B(e)
        ? this.kingAttackers(e, this.turn, this.board.occupied).nonEmpty()
          ? ye.err(new ht(dt.OppositeCheck))
          : _e.backranks().intersects(this.board.pawn)
          ? ye.err(new ht(dt.PawnsOnBackrank))
          : this.validateCheckers()
        : ye.err(new ht(dt.Kings));
    }
    validateCheckers() {
      const e = this.board.kingOf(this.turn);
      if (B(e)) {
        const t = this.kingAttackers(e, K(this.turn), this.board.occupied);
        if (t.size() > 2 || (2 === t.size() && lt(t.first(), t.last()).has(e)))
          return ye.err(new ht(dt.ImpossibleCheck));
        if (B(this.epSquare))
          for (const n of t)
            if (lt(n, this.epSquare).has(e))
              return ye.err(new ht(dt.ImpossibleCheck));
      }
      return ye.ok(void 0);
    }
    validEpSquare(e) {
      if (!B(e)) return;
      const t = "white" === this.turn ? 5 : 2,
        n = "white" === this.turn ? 8 : -8;
      if (F(e) !== t) return;
      if (this.board.occupied.has(e + n)) return;
      const o = e - n;
      return this.board.pawn.has(o) && this.board[K(this.turn)].has(o)
        ? e
        : void 0;
    }
    castlingDest(e, t) {
      if (!B(t.king) || t.checkers.nonEmpty()) return _e.empty();
      const n = this.castles.rook[this.turn][e];
      if (!B(n)) return _e.empty();
      if (this.castles.path[this.turn][e].intersects(this.board.occupied))
        return _e.empty();
      const o = Q(this.turn, e),
        r = ut(t.king, o),
        i = this.board.occupied.without(t.king);
      for (const c of r)
        if (this.kingAttackers(c, K(this.turn), i).nonEmpty())
          return _e.empty();
      const s = pt(this.turn, e),
        a = this.board.occupied.toggle(t.king).toggle(n).toggle(s);
      return this.kingAttackers(o, K(this.turn), a).nonEmpty()
        ? _e.empty()
        : _e.fromSquare(n);
    }
    canCaptureEp(e, t) {
      if (!B(this.epSquare)) return !1;
      if (!Ze(this.turn, e).has(this.epSquare)) return !1;
      if (!B(t.king)) return !0;
      const n = this.epSquare + ("white" === this.turn ? -8 : 8),
        o = this.board.occupied.toggle(e).toggle(this.epSquare).toggle(n);
      return !this.kingAttackers(t.king, K(this.turn), o).intersects(o);
    }
    pseudoDests(e, t) {
      if (t.variantEnd) return _e.empty();
      const n = this.board.get(e);
      if (!n || n.color !== this.turn) return _e.empty();
      let o = ct(n, e, this.board.occupied);
      if ("pawn" === n.role) {
        let t = this.board[K(this.turn)];
        B(this.epSquare) && (t = t.with(this.epSquare)), (o = o.intersect(t));
        const n = "white" === this.turn ? 8 : -8,
          r = e + n;
        if (0 <= r && r < 64 && !this.board.occupied.has(r)) {
          o = o.with(r);
          const t = r + n;
          ("white" === this.turn ? e < 16 : e >= 48) &&
            !this.board.occupied.has(t) &&
            (o = o.with(t));
        }
        return o;
      }
      return (
        (o = o.diff(this.board[this.turn])),
        e === t.king
          ? o.union(this.castlingDest("a", t)).union(this.castlingDest("h", t))
          : o
      );
    }
    dests(e, t) {
      if ((t = t || this.ctx()).variantEnd) return _e.empty();
      const n = this.board.get(e);
      if (!n || n.color !== this.turn) return _e.empty();
      let o, r;
      if ("pawn" === n.role) {
        o = Ze(this.turn, e).intersect(this.board[K(this.turn)]);
        const n = "white" === this.turn ? 8 : -8,
          i = e + n;
        if (0 <= i && i < 64 && !this.board.occupied.has(i)) {
          o = o.with(i);
          const t = i + n;
          ("white" === this.turn ? e < 16 : e >= 48) &&
            !this.board.occupied.has(t) &&
            (o = o.with(t));
        }
        if (B(this.epSquare) && this.canCaptureEp(e, t)) {
          const e = this.epSquare - n;
          (t.checkers.isEmpty() || t.checkers.singleSquare() === e) &&
            (r = _e.fromSquare(this.epSquare));
        }
      } else
        o =
          "bishop" === n.role
            ? it(e, this.board.occupied)
            : "knight" === n.role
            ? Je(e)
            : "rook" === n.role
            ? st(e, this.board.occupied)
            : "queen" === n.role
            ? at(e, this.board.occupied)
            : Ye(e);
      if (((o = o.diff(this.board[this.turn])), B(t.king))) {
        if ("king" === n.role) {
          const n = this.board.occupied.without(e);
          for (const e of o)
            this.kingAttackers(e, K(this.turn), n).nonEmpty() &&
              (o = o.without(e));
          return o
            .union(this.castlingDest("a", t))
            .union(this.castlingDest("h", t));
        }
        if (t.checkers.nonEmpty()) {
          const e = t.checkers.singleSquare();
          if (!B(e)) return _e.empty();
          o = o.intersect(ut(e, t.king).with(e));
        }
        t.blockers.has(e) && (o = o.intersect(lt(e, t.king)));
      }
      return r && (o = o.union(r)), o;
    }
    isVariantEnd() {
      return !1;
    }
    variantOutcome(e) {}
    hasInsufficientMaterial(e) {
      if (
        this.board[e]
          .intersect(this.board.pawn.union(this.board.rooksAndQueens()))
          .nonEmpty()
      )
        return !1;
      if (this.board[e].intersects(this.board.knight))
        return (
          this.board[e].size() <= 2 &&
          this.board[K(e)]
            .diff(this.board.king)
            .diff(this.board.queen)
            .isEmpty()
        );
      if (this.board[e].intersects(this.board.bishop)) {
        return (
          (!this.board.bishop.intersects(_e.darkSquares()) ||
            !this.board.bishop.intersects(_e.lightSquares())) &&
          this.board.pawn.isEmpty() &&
          this.board.knight.isEmpty()
        );
      }
      return !0;
    }
  }
  class vt extends mt {
    constructor() {
      super("crazyhouse");
    }
    static default() {
      const e = super.default();
      return (e.pockets = Ae.empty()), e;
    }
    static fromSetup(e) {
      return super
        .fromSetup(e)
        .map(
          (t) => ((t.pockets = e.pockets ? e.pockets.clone() : Ae.empty()), t)
        );
    }
    validate() {
      return super
        .validate()
        .chain((e) =>
          this.pockets &&
          (this.pockets.white.king > 0 || this.pockets.black.king > 0)
            ? ye.err(new ht(dt.Kings))
            : (this.pockets ? this.pockets.count() : 0) +
                this.board.occupied.size() >
              64
            ? ye.err(new ht(dt.Variant))
            : ye.ok(void 0)
        );
    }
    clone() {
      return super.clone();
    }
    hasInsufficientMaterial(e) {
      return this.pockets
        ? this.board.occupied.size() + this.pockets.count() <= 3 &&
            this.board.pawn.isEmpty() &&
            this.board.promoted.isEmpty() &&
            this.board.rooksAndQueens().isEmpty() &&
            this.pockets.white.pawn <= 0 &&
            this.pockets.black.pawn <= 0 &&
            this.pockets.white.rook <= 0 &&
            this.pockets.black.rook <= 0 &&
            this.pockets.white.queen <= 0 &&
            this.pockets.black.queen <= 0
        : super.hasInsufficientMaterial(e);
    }
    dropDests(e) {
      var t, n;
      const o = this.board.occupied
        .complement()
        .intersect(
          (
            null === (t = this.pockets) || void 0 === t
              ? void 0
              : t[this.turn].hasNonPawns()
          )
            ? _e.full()
            : (
                null === (n = this.pockets) || void 0 === n
                  ? void 0
                  : n[this.turn].hasPawns()
              )
            ? _e.backranks().complement()
            : _e.empty()
        );
      if (B((e = e || this.ctx()).king) && e.checkers.nonEmpty()) {
        const t = e.checkers.singleSquare();
        return B(t) ? o.intersect(ut(t, e.king)) : _e.empty();
      }
      return o;
    }
  }
  class gt extends mt {
    constructor() {
      super("atomic");
    }
    static default() {
      return super.default();
    }
    static fromSetup(e) {
      return super.fromSetup(e);
    }
    clone() {
      return super.clone();
    }
    validate() {
      if (this.board.occupied.isEmpty()) return ye.err(new ht(dt.Empty));
      if (this.board.king.size() > 2) return ye.err(new ht(dt.Kings));
      const e = this.board.kingOf(K(this.turn));
      return B(e)
        ? this.kingAttackers(e, this.turn, this.board.occupied).nonEmpty()
          ? ye.err(new ht(dt.OppositeCheck))
          : _e.backranks().intersects(this.board.pawn)
          ? ye.err(new ht(dt.PawnsOnBackrank))
          : ye.ok(void 0)
        : ye.err(new ht(dt.Kings));
    }
    kingAttackers(e, t, n) {
      const o = this.board.pieces(t, "king");
      return o.isEmpty() || Ye(e).intersects(o)
        ? _e.empty()
        : super.kingAttackers(e, t, n);
    }
    playCaptureAt(e, t) {
      super.playCaptureAt(e, t), this.board.take(e);
      for (const n of Ye(e)
        .intersect(this.board.occupied)
        .diff(this.board.pawn)) {
        const e = this.board.take(n);
        e && "rook" === e.role && this.castles.discardRook(n),
          e && "king" === e.role && this.castles.discardSide(e.color);
      }
    }
    hasInsufficientMaterial(e) {
      if (this.board.pieces(K(e), "king").isEmpty()) return !1;
      if (this.board[e].diff(this.board.king).isEmpty()) return !0;
      if (this.board[K(e)].diff(this.board.king).nonEmpty()) {
        if (
          this.board.occupied.equals(this.board.bishop.union(this.board.king))
        ) {
          if (
            !this.board.bishop
              .intersect(this.board.white)
              .intersects(_e.darkSquares())
          )
            return !this.board.bishop
              .intersect(this.board.black)
              .intersects(_e.lightSquares());
          if (
            !this.board.bishop
              .intersect(this.board.white)
              .intersects(_e.lightSquares())
          )
            return !this.board.bishop
              .intersect(this.board.black)
              .intersects(_e.darkSquares());
        }
        return !1;
      }
      return (
        !this.board.queen.nonEmpty() &&
        !this.board.pawn.nonEmpty() &&
        (!!this.board.knight
          .union(this.board.bishop)
          .union(this.board.rook)
          .isSingleSquare() ||
          (!!this.board.occupied.equals(
            this.board.knight.union(this.board.king)
          ) &&
            this.board.knight.size() <= 2))
      );
    }
    dests(e, t) {
      t = t || this.ctx();
      let n = _e.empty();
      for (const o of this.pseudoDests(e, t)) {
        const t = this.clone();
        t.play({ from: e, to: o });
        const r = t.board.kingOf(this.turn);
        !B(r) ||
          (B(t.board.kingOf(t.turn)) &&
            !t.kingAttackers(r, t.turn, t.board.occupied).isEmpty()) ||
          (n = n.with(o));
      }
      return n;
    }
    isVariantEnd() {
      return !!this.variantOutcome();
    }
    variantOutcome(e) {
      for (const t of D)
        if (this.board.pieces(t, "king").isEmpty()) return { winner: K(t) };
    }
  }
  class bt extends mt {
    constructor() {
      super("antichess");
    }
    static default() {
      const e = super.default();
      return (e.castles = ft.empty()), e;
    }
    static fromSetup(e) {
      return super.fromSetup(e).map((e) => ((e.castles = ft.empty()), e));
    }
    clone() {
      return super.clone();
    }
    validate() {
      return this.board.occupied.isEmpty()
        ? ye.err(new ht(dt.Empty))
        : _e.backranks().intersects(this.board.pawn)
        ? ye.err(new ht(dt.PawnsOnBackrank))
        : ye.ok(void 0);
    }
    kingAttackers(e, t, n) {
      return _e.empty();
    }
    ctx() {
      const e = super.ctx(),
        t = this.board[K(this.turn)];
      for (const n of this.board[this.turn])
        if (this.pseudoDests(n, e).intersects(t)) {
          e.mustCapture = !0;
          break;
        }
      return e;
    }
    dests(e, t) {
      t = t || this.ctx();
      const n = this.pseudoDests(e, t);
      return t.mustCapture ? n.intersect(this.board[K(this.turn)]) : n;
    }
    hasInsufficientMaterial(e) {
      if (this.board.occupied.equals(this.board.bishop)) {
        const t = this.board[e].intersects(_e.lightSquares()),
          n = this.board[e].intersects(_e.darkSquares()),
          o = this.board[K(e)].isDisjoint(_e.lightSquares()),
          r = this.board[K(e)].isDisjoint(_e.darkSquares());
        return (t && o) || (n && r);
      }
      return !1;
    }
    isVariantEnd() {
      return this.board[this.turn].isEmpty();
    }
    variantOutcome(e) {
      if ((e = e || this.ctx()).variantEnd || this.isStalemate(e))
        return { winner: this.turn };
    }
  }
  class kt extends mt {
    constructor() {
      super("kingofthehill");
    }
    static default() {
      return super.default();
    }
    static fromSetup(e) {
      return super.fromSetup(e);
    }
    clone() {
      return super.clone();
    }
    hasInsufficientMaterial(e) {
      return !1;
    }
    isVariantEnd() {
      return this.board.king.intersects(_e.center());
    }
    variantOutcome(e) {
      for (const t of D)
        if (this.board.pieces(t, "king").intersects(_e.center()))
          return { winner: t };
    }
  }
  class wt extends mt {
    constructor() {
      super("3check");
    }
    static default() {
      const e = super.default();
      return (e.remainingChecks = Oe.default()), e;
    }
    static fromSetup(e) {
      return super
        .fromSetup(e)
        .map(
          (t) => (
            (t.remainingChecks = e.remainingChecks
              ? e.remainingChecks.clone()
              : Oe.default()),
            t
          )
        );
    }
    clone() {
      return super.clone();
    }
    hasInsufficientMaterial(e) {
      return this.board.pieces(e, "king").equals(this.board[e]);
    }
    isVariantEnd() {
      return (
        !!this.remainingChecks &&
        (this.remainingChecks.white <= 0 || this.remainingChecks.black <= 0)
      );
    }
    variantOutcome(e) {
      if (this.remainingChecks)
        for (const t of D)
          if (this.remainingChecks[t] <= 0) return { winner: t };
    }
  }
  class yt extends mt {
    constructor() {
      super("racingkings");
    }
    static default() {
      const e = new this();
      return (
        (e.board = Pe.racingKings()),
        (e.pockets = void 0),
        (e.turn = "white"),
        (e.castles = ft.empty()),
        (e.epSquare = void 0),
        (e.remainingChecks = void 0),
        (e.halfmoves = 0),
        (e.fullmoves = 1),
        e
      );
    }
    static fromSetup(e) {
      return super.fromSetup(e).map((e) => ((e.castles = ft.empty()), e));
    }
    validate() {
      return this.isCheck()
        ? ye.err(new ht(dt.ImpossibleCheck))
        : this.board.pawn.nonEmpty()
        ? ye.err(new ht(dt.Variant))
        : super.validate();
    }
    clone() {
      return super.clone();
    }
    dests(e, t) {
      if (e === (t = t || this.ctx()).king) return super.dests(e, t);
      let n = _e.empty();
      for (const o of super.dests(e, t)) {
        const t = { from: e, to: o },
          r = this.clone();
        r.play(t), r.isCheck() || (n = n.with(o));
      }
      return n;
    }
    hasInsufficientMaterial(e) {
      return !1;
    }
    isVariantEnd() {
      const e = _e.fromRank(7),
        t = this.board.king.intersect(e);
      if (t.isEmpty()) return !1;
      if ("white" === this.turn || t.intersects(this.board.black)) return !0;
      const n = this.board.kingOf("black");
      if (B(n)) {
        const t = this.board.occupied.without(n);
        for (const o of Ye(n).intersect(e).diff(this.board.black))
          if (this.kingAttackers(o, "white", t).isEmpty()) return !1;
      }
      return !0;
    }
    variantOutcome(e) {
      if (e ? !e.variantEnd : !this.isVariantEnd()) return;
      const t = _e.fromRank(7),
        n = this.board.pieces("black", "king").intersects(t),
        o = this.board.pieces("white", "king").intersects(t);
      return n && !o
        ? { winner: "black" }
        : o && !n
        ? { winner: "white" }
        : { winner: void 0 };
    }
  }
  class zt extends mt {
    constructor() {
      super("horde");
    }
    static default() {
      const e = new this();
      return (
        (e.board = Pe.horde()),
        (e.pockets = void 0),
        (e.turn = "white"),
        (e.castles = ft.default()),
        e.castles.discardSide("white"),
        (e.epSquare = void 0),
        (e.remainingChecks = void 0),
        (e.halfmoves = 0),
        (e.fullmoves = 1),
        e
      );
    }
    static fromSetup(e) {
      return super.fromSetup(e);
    }
    validate() {
      if (this.board.occupied.isEmpty()) return ye.err(new ht(dt.Empty));
      if (!this.board.king.isSingleSquare()) return ye.err(new ht(dt.Kings));
      if (!this.board.king.diff(this.board.promoted).isSingleSquare())
        return ye.err(new ht(dt.Kings));
      const e = this.board.kingOf(K(this.turn));
      if (
        B(e) &&
        this.kingAttackers(e, this.turn, this.board.occupied).nonEmpty()
      )
        return ye.err(new ht(dt.OppositeCheck));
      for (const t of D)
        if (this.board.pieces(t, "pawn").intersects(_e.backrank(K(t))))
          return ye.err(new ht(dt.PawnsOnBackrank));
      return this.validateCheckers();
    }
    clone() {
      return super.clone();
    }
    hasInsufficientMaterial(e) {
      return !1;
    }
    isVariantEnd() {
      return this.board.white.isEmpty() || this.board.black.isEmpty();
    }
    variantOutcome(e) {
      return this.board.white.isEmpty()
        ? { winner: "black" }
        : this.board.black.isEmpty()
        ? { winner: "white" }
        : void 0;
    }
  }
  function St(e, t) {
    switch (e) {
      case "chess":
        return mt.fromSetup(t);
      case "antichess":
        return bt.fromSetup(t);
      case "atomic":
        return gt.fromSetup(t);
      case "horde":
        return zt.fromSetup(t);
      case "racingkings":
        return yt.fromSetup(t);
      case "kingofthehill":
        return kt.fromSetup(t);
      case "3check":
        return wt.fromSetup(t);
      case "crazyhouse":
        return vt.fromSetup(t);
    }
  }
  function Ct(e, t) {
    return new WebAssembly.Memory({ shared: !0, initial: e, maximum: t });
  }
  function xt() {
    return (
      lichess.tempStorage.get("ceval.enabled-after") ===
      (lichess.storage.get("ceval.disable") || "1")
    );
  }
  function Et(e) {
    var t;
    const n = (t) => (e.storageKeyPrefix ? `${e.storageKeyPrefix}.${t}` : t),
      o = se(
        "ceval.enable-nnue",
        !(null === (t = navigator.connection) || void 0 === t
          ? void 0
          : t.saveData)
      ),
      r = e.initialFen ? Be(e.initialFen).unwrap() : void 0,
      i = J(e.variant.key),
      s = !r || St(i, r).isOk,
      a =
        (!r ||
          D.every((e) => {
            const t = r.board,
              n = t[e],
              o =
                Math.max(t.queen.intersect(n).size() - 1, 0) +
                Math.max(t.rook.intersect(n).size() - 2, 0) +
                Math.max(t.knight.intersect(n).size() - 2, 0) +
                Math.max(
                  t.bishop.intersect(n).intersect(_e.lightSquares()).size() - 1,
                  0
                ) +
                Math.max(
                  t.bishop.intersect(n).intersect(_e.darkSquares()).size() - 1,
                  0
                );
            return t.pawn.intersect(n).size() + o <= 8;
          })) &&
        "chess" == i;
    let c = "asmjs",
      l = !1,
      u = !1;
    const d = Uint8Array.from([0, 97, 115, 109, 1, 0, 0, 0]);
    if (
      "object" == typeof WebAssembly &&
      "function" == typeof WebAssembly.validate &&
      WebAssembly.validate(d)
    ) {
      c = "wasm";
      const e = (function (e, t) {
        if ("object" != typeof Atomics) return;
        if ("function" != typeof SharedArrayBuffer) return;
        const n = Ct(e, t);
        if (n.buffer instanceof SharedArrayBuffer) {
          try {
            window.postMessage(n, "*");
          } catch (Ce) {
            return;
          }
          return n;
        }
      })(8, 16);
      if (e) {
        c = "hce";
        const t = Uint8Array.from([
          0, 97, 115, 109, 1, 0, 0, 0, 1, 12, 2, 96, 2, 123, 123, 1, 123, 96, 1,
          123, 1, 123, 3, 3, 2, 0, 1, 7, 9, 2, 1, 97, 0, 0, 1, 98, 0, 1, 10, 19,
          2, 9, 0, 32, 0, 32, 1, 253, 186, 1, 11, 7, 0, 32, 0, 253, 253, 1, 11,
        ]);
        (u = WebAssembly.validate(t)), u && a && o() && (c = "nnue");
        try {
          e.grow(8), (l = !0);
        } catch (Ce) {}
      }
    }
    const h = a ? 2 : 1,
      p = Math.min(
        Math.max((navigator.hardwareConcurrency || 1) - 1, 1),
        l ? 32 : h
      ),
      f = se(
        n("ceval.threads"),
        Math.min(Math.ceil((navigator.hardwareConcurrency || 1) / 4), p)
      ),
      m = "hce" == c || "nnue" == c ? 2 : 0.5,
      v = Math.min((1024 * (navigator.deviceMemory || m)) / 8, l ? 1024 : 16),
      g = se(n("ceval.hash-size"), 16),
      b = se(n("ceval.multipv"), e.multiPvDefault || 1),
      k = se("ceval.infinite", !1);
    let y = null;
    const z = w(!0),
      S = w(e.possible && s && z() && xt()),
      C = w(0);
    let x = !1,
      E = !1;
    const M = w(null),
      _ = w(null),
      q = w(!1),
      A = {
        variant: e.variant.key,
        threads:
          ("hce" == c || "nnue" == c) && (() => Math.min(parseInt(f()), p)),
        hashSize:
          ("hce" == c || "nnue" == c) && (() => Math.min(parseInt(g()), v)),
      };
    let O,
      R = null;
    const N = P(200, (t, n) => {
        I(t.pvs, n.ply % 2 == (n.threatMode ? 1 : 0) ? "white" : "black"),
          (y = t),
          e.emit(t, n),
          t.fen !== R &&
            xt() &&
            ((R = t.fen), lichess.storage.fire("ceval.fen", t.fen));
      }),
      T = () => (y ? y.depth : 0),
      $ = () =>
        q() || k()
          ? 99
          : (function (e, t, n) {
              switch (e) {
                case "asmjs":
                  return 18;
                case "wasm":
                  return 20;
                default:
                  return 22 + Math.min(Math.max(t - n, 0), 6);
              }
            })(c, A.threads ? A.threads() : 1, parseInt(b())),
      I = (e, t) =>
        e.sort(function (e, n) {
          return ue(t, n) - ue(t, e);
        }),
      L = (t, n, o) => {
        if (!S() || !e.possible || !xt()) return;
        const r = $(),
          i = n[n.length - 1],
          s = o ? i.threat : i.ceval;
        if (s && s.depth >= r)
          return void (E = { path: t, steps: n, threatMode: o });
        const u = {
          initialFen: n[0].fen,
          moves: [],
          currentFen: i.fen,
          path: t,
          ply: i.ply,
          maxDepth: r,
          multiPv: parseInt(b()),
          threatMode: o,
          emit(e) {
            S() && N(e, u);
          },
          stopRequested: !1,
        };
        if (o) {
          const e = i.ply % 2 == 1 ? "w" : "b",
            t = i.fen.replace(/ (w|b) /, " " + e + " ");
          (u.currentFen = t), (u.initialFen = t);
        } else
          for (let a = 1; a < n.length; a++) {
            const t = n[a];
            (d = e.variant.key),
              (h = t.san).startsWith("O-O") ||
              ("crazyhouse" !== d &&
                (h.includes("x") ||
                  h.toLowerCase() === h ||
                  ("threeCheck" === d && h.includes("+"))))
                ? ((u.moves = []), (u.initialFen = t.fen))
                : u.moves.push(t.uci);
          }
        var d, h;
        lichess.storage.fire("ceval.disable"),
          lichess.tempStorage.set(
            "ceval.enabled-after",
            lichess.storage.get("ceval.disable")
          ),
          O ||
            (O =
              "nnue" == c
                ? new re(A, {
                    baseUrl: "vendor/stockfish-nnue.wasm/",
                    module: "Stockfish",
                    downloadProgress: P(200, (t) => {
                      C(t), e.redraw();
                    }),
                    version: "b6939d",
                    wasmMemory: Ct(2048, l ? 32768 : 2048),
                    cache: new ke("ceval-wasm-cache"),
                  })
                : "hce" == c
                ? new re(A, {
                    baseUrl: a
                      ? "vendor/stockfish.wasm/"
                      : "vendor/stockfish-mv.wasm/",
                    module: a ? "Stockfish" : "StockfishMv",
                    version: "a022fa",
                    wasmMemory: Ct(1024, l ? 32768 : 1088),
                  })
                : new oe(A, {
                    url:
                      "wasm" == c
                        ? "vendor/stockfish.js/stockfish.wasm.js"
                        : "vendor/stockfish.js/stockfish.js",
                  })),
          O.start(u),
          (x = !0),
          (E = { path: t, steps: n, threatMode: o });
      };
    function B() {
      S() && x && (null == O || O.stop(), (x = !1));
    }
    return {
      technology: c,
      start: (e, t, n) => {
        q(!1), L(e, t, !!n);
      },
      stop: B,
      allowed: z,
      possible: e.possible,
      enabled: S,
      downloadProgress: C,
      multiPv: b,
      threads: "hce" == c || "nnue" == c ? f : void 0,
      hashSize: "hce" == c || "nnue" == c ? g : void 0,
      maxThreads: p,
      maxHashSize: v,
      infinite: k,
      supportsNnue: u,
      enableNnue: o,
      hovering: M,
      setHovering(t, n) {
        M(n ? { fen: t, uci: n } : null), e.setAutoShapes();
      },
      pvBoard: _,
      setPvBoard(t) {
        _(t), e.redraw();
      },
      toggle() {
        if (e.possible && z())
          if ((B(), S() || document.hidden))
            lichess.tempStorage.set("ceval.enabled-after", ""), S(!1);
          else {
            const e = lichess.storage.get("ceval.disable") || "1";
            e && lichess.tempStorage.set("ceval.enabled-after", e), S(!0);
          }
      },
      curDepth: T,
      effectiveMaxDepth: $,
      variant: e.variant,
      isDeeper: q,
      goDeeper: function () {
        q(!0),
          E &&
            (k() ? y && e.emit(y, E) : (B(), L(E.path, E.steps, E.threatMode)));
      },
      canGoDeeper: () =>
        T() < 99 &&
        !q() &&
        ((!k() && !(null == O ? void 0 : O.isComputing())) ||
          (() => {
            var e;
            return (
              !!E &&
              !!(null === (e = E.steps[E.steps.length - 1].ceval) ||
              void 0 === e
                ? void 0
                : e.cloud)
            );
          })()),
      isComputing: () => !!x && !!(null == O ? void 0 : O.isComputing()),
      engineName: () => (null == O ? void 0 : O.engineName()),
      destroy: () => (null == O ? void 0 : O.destroy()),
      redraw: e.redraw,
      analysable: s,
    };
  }
  function Mt(e, t) {
    var n;
    const o = (function (e, t) {
      let n = "";
      if (L(t))
        "pawn" !== t.role && (n = W(t.role).toUpperCase()),
          (n += "@" + H(t.to));
      else {
        const o = e.board.getRole(t.from);
        if (!o) return "--";
        if (
          "king" !== o ||
          (!e.board[e.turn].has(t.to) && 2 !== Math.abs(t.to - t.from))
        ) {
          const r =
            e.board.occupied.has(t.to) ||
            ("pawn" === o && V(t.from) !== V(t.to));
          if ("pawn" !== o) {
            let r;
            if (
              ((n = W(o).toUpperCase()),
              (r =
                "king" === o
                  ? Ye(t.to).intersect(e.board.king)
                  : "queen" === o
                  ? at(t.to, e.board.occupied).intersect(e.board.queen)
                  : "rook" === o
                  ? st(t.to, e.board.occupied).intersect(e.board.rook)
                  : "bishop" === o
                  ? it(t.to, e.board.occupied).intersect(e.board.bishop)
                  : Je(t.to).intersect(e.board.knight)),
              (r = r.intersect(e.board[e.turn]).without(t.from)),
              r.nonEmpty())
            ) {
              const o = e.ctx();
              for (const n of r) e.dests(n, o).has(t.to) || (r = r.without(n));
              if (r.nonEmpty()) {
                let e = !1,
                  o = r.intersects(_e.fromRank(F(t.from)));
                r.intersects(_e.fromFile(V(t.from))) ? (e = !0) : (o = !0),
                  o && (n += R[V(t.from)]),
                  e && (n += N[F(t.from)]);
              }
            }
          } else r && (n = R[V(t.from)]);
          r && (n += "x"),
            (n += H(t.to)),
            t.promotion && (n += "=" + W(t.promotion).toUpperCase());
        } else n = t.to > t.from ? "O-O" : "O-O-O";
      }
      return n;
    })(e, t);
    return (
      e.play(t),
      (null === (n = e.outcome()) || void 0 === n ? void 0 : n.winner)
        ? o + "#"
        : e.isCheck()
        ? o + "+"
        : o
    );
  }
  let _t = 0;
  const Pt = [...Array(8).keys()].map((e) =>
    d(3 === e ? "tick.zero" : "tick", {
      attrs: { style: `height: ${12.5 * (e + 1)}%` },
    })
  );
  function qt(e, t) {
    const n = e.getCeval(),
      o = e.trans;
    if (!t.client) {
      if (!n.analysable) return ["Engine cannot analyze this position"];
      const r = n.downloadProgress() / 1024 / 1024;
      return [
        t.server && e.nextNodeBest()
          ? o.noarg("usingServerAnalysis")
          : o.noarg("loadingEngine") + (r >= 1 ? ` (${r.toFixed(1)} MiB)` : ""),
      ];
    }
    const r = t.client.depth || 0,
      i = t.client.cloud
        ? [
            o("depthX", r),
            d(
              "span.cloud",
              { attrs: { title: o.noarg("cloudAnalysis") } },
              "Cloud"
            ),
          ]
        : [o("depthX", r + "/" + Math.max(r, t.client.maxDepth))];
    return (
      n.canGoDeeper()
        ? i.push(
            d("a.deeper", {
              attrs: { title: o.noarg("goDeeper"), "data-icon": "" },
              hook: {
                insert: (e) =>
                  e.elm.addEventListener("click", () => {
                    n.goDeeper(), n.redraw();
                  }),
              },
            })
          )
        : !t.client.cloud &&
          t.client.knps &&
          i.push(", " + Math.round(t.client.knps) + "k nodes/s"),
      i
    );
  }
  function At(e, t) {
    if (!t) return e.trans.noarg("loadingEngine");
    let n = e.trans("depthX", (t.depth || 0) + "/" + t.maxDepth);
    return t.knps && (n += ", " + Math.round(t.knps) + "k nodes/s"), n;
  }
  function Ot(e) {
    return e.disableThreatMode && e.disableThreatMode()
      ? null
      : d("a.show-threat", {
          class: { active: e.threatMode(), hidden: !!e.getNode().check },
          attrs: {
            "data-icon": "",
            title: e.trans.noarg("showThreat") + " (x)",
          },
          hook: {
            insert: (t) => t.elm.addEventListener("click", e.toggleThreatMode),
          },
        });
  }
  function Rt(e) {
    return [
      d(
        "span",
        { attrs: { title: e.engineName() || "" } },
        "nnue" == e.technology
          ? "Stockfish 14+"
          : "hce" == e.technology
          ? "Stockfish 11+"
          : "Stockfish 10+"
      ),
      "nnue" == e.technology
        ? d(
            "span.technology.good",
            {
              attrs: {
                title:
                  "Multi-threaded WebAssembly with SIMD (efficiently updatable neural network, using 4x smaller net by Sopel97)",
              },
            },
            "NNUE"
          )
        : "hce" == e.technology
        ? d(
            "span.technology.good",
            {
              attrs: {
                title:
                  "Multi-threaded WebAssembly (classical hand crafted evaluation)",
              },
            },
            "HCE"
          )
        : "wasm" == e.technology
        ? d(
            "span.technology",
            { attrs: { title: "Single-threaded WebAssembly fallback (slow)" } },
            "WASM"
          )
        : d(
            "span.technology",
            {
              attrs: {
                title: "Single-threaded JavaScript fallback (very slow)",
              },
            },
            "ASMJS"
          ),
    ];
  }
  function Nt(e) {
    const t = e.server,
      n = e.client;
    return t
      ? n &&
        (n.nodes > 4e6 ||
          (void 0 !== n.mate &&
            (void 0 === t.mate || Math.abs(n.mate) < Math.abs(t.mate))))
        ? n
        : t
      : n;
  }
  function Dt(e) {
    if (e.ongoing || !e.showEvalGauge()) return;
    const t = Nt(e.currentEvals());
    let n;
    return (
      t ? ((n = ue("white", t)), (_t = n)) : (n = _t),
      d(
        "div.eval-gauge",
        {
          class: { empty: null === n, reverse: "black" === e.getOrientation() },
        },
        [
          d("div.black", {
            attrs: { style: `height: ${100 - 50 * (n + 1)}%` },
          }),
          ...Pt,
        ]
      )
    );
  }
  function Tt(e) {
    const t = e.getCeval(),
      n = e.trans;
    if (!t.allowed() || !t.possible || !e.showComputer()) return;
    const o = t.enabled(),
      r = e.currentEvals(),
      i = e.threatMode(),
      s = i && e.getNode().threat,
      a = s || Nt(r);
    let c, l;
    a && void 0 !== a.cp
      ? ((c = he(a.cp)),
        (l = r.client
          ? r.client.cloud
            ? 100
            : Math.min(
                100,
                Math.round((100 * r.client.depth) / r.client.maxDepth)
              )
          : 0))
      : a && b(a.mate)
      ? ((c = "#" + a.mate), (l = 100))
      : e.outcome()
      ? ((c = "-"), (l = 0))
      : ((c = d(o ? "i.ddloader" : "i")), (l = 0)),
      i &&
        (l = s ? Math.min(100, Math.round((100 * s.depth) / s.maxDepth)) : 0);
    const u = o
        ? d(
            "div.bar",
            d("span", {
              class: { threat: i },
              attrs: { style: `width: ${l}%` },
              hook: {
                postpatch: (e, t) => {
                  if (e.data.percent > l || !!e.data.threatMode != i) {
                    const e = t.elm,
                      n = e.parentNode;
                    n.removeChild(e), n.appendChild(e);
                  }
                  (t.data.percent = l), (t.data.threatMode = i);
                },
              },
            })
          )
        : null,
      h = o
        ? [
            d("pearl", [c]),
            d("div.engine", [
              ...(i ? [n.noarg("showThreat")] : Rt(t)),
              d(
                "span.info",
                e.outcome() ? [n.noarg("gameOver")] : i ? [At(e, s)] : qt(e, r)
              ),
            ]),
          ]
        : [
            c ? d("pearl", [c]) : null,
            d("help", [
              ...Rt(t),
              d("br"),
              t.analysable
                ? n.noarg("inLocalBrowser")
                : "Engine cannot analyse this game",
            ]),
          ],
      p =
        e.mandatoryCeval && e.mandatoryCeval()
          ? null
          : d(
              "div.switch",
              { attrs: { title: n.noarg("toggleLocalEvaluation") + " (L)" } },
              [
                d("input#analyse-toggle-ceval.cmn-toggle.cmn-toggle--subtle", {
                  attrs: {
                    type: "checkbox",
                    checked: o,
                    disabled: !t.analysable,
                  },
                  hook: {
                    insert: (t) =>
                      t.elm.addEventListener("change", e.toggleCeval),
                  },
                }),
                d("label", { attrs: { for: "analyse-toggle-ceval" } }),
              ]
            );
    return d(
      "div.ceval" + (o ? ".enabled" : ""),
      { class: { computing: l < 100 && t.isComputing() } },
      [u, ...h, Ot(e), p]
    );
  }
  function $t(e) {
    return e.getAttribute("data-fen");
  }
  function It(e) {
    return Lt(e)
      .filter(k)
      .map((e) => e.split("|")[1]);
  }
  function Lt(e) {
    const t = [];
    return (
      $(e.target)
        .closest("div.pv")
        .children()
        .filter("span.pv-san")
        .each(function () {
          t.push($(this).attr("data-board"));
        }),
      t
    );
  }
  function Bt(e, t) {
    lichess.requestIdleCallback(
      () =>
        t.setHovering(
          $t(e),
          $(e).find("div.pv:hover").attr("data-uci") || void 0
        ),
      500
    );
  }
  function Kt(e) {
    const t = e.getCeval();
    if (!t.allowed() || !t.possible || !t.enabled()) return;
    const n = parseInt(t.multiPv()),
      o = e.getNode(),
      r = Be(o.fen).unwrap();
    let i,
      s,
      a,
      c = !1;
    e.threatMode() && o.threat
      ? ((i = o.threat.pvs), (c = !0))
      : (i = o.ceval ? o.ceval.pvs : []),
      c && ((r.turn = K(r.turn)), "white" == r.turn && (r.fullmoves += 1));
    const l = St(J(t.variant.key), r);
    return d(
      "div.pv_box",
      {
        attrs: { "data-fen": o.fen },
        hook: {
          insert: (n) => {
            const o = n.elm;
            o.addEventListener("mouseover", (t) => {
              const n = e.getCeval();
              n.setHovering(
                $t(o),
                (function (e) {
                  return (
                    $(e.target).closest("div.pv").attr("data-uci") || void 0
                  );
                })(t)
              );
              const r = t.target.dataset.board;
              if (r) {
                (a = Number(t.target.dataset.moveIndex)), (s = Lt(t));
                const [e, o] = r.split("|");
                n.setPvBoard({ fen: e, uci: o });
              }
            }),
              o.addEventListener("wheel", (t) => {
                if ((t.preventDefault(), null != a && null != s)) {
                  t.deltaY < 0 && a > 0
                    ? (a -= 1)
                    : t.deltaY > 0 && a < s.length - 1 && (a += 1);
                  const n = s[a];
                  if (n) {
                    const [t, o] = n.split("|");
                    e.getCeval().setPvBoard({ fen: t, uci: o });
                  }
                }
              }),
              o.addEventListener("mouseout", () =>
                e.getCeval().setHovering($t(o))
              );
            for (const t of ["touchstart", "mousedown"])
              o.addEventListener(t, (t) => {
                const n = It(t);
                n.length > (null != a ? a : 0) &&
                  !e.threatMode() &&
                  (e.playUciList(n.slice(0, (null != a ? a : 0) + 1)),
                  t.preventDefault());
              });
            o.addEventListener("mouseleave", () => {
              e.getCeval().setPvBoard(null), (a = null);
            }),
              Bt(o, t);
          },
          postpatch: (e, n) => Bt(n.elm, t),
        },
      },
      [
        ...[...Array(n).keys()].map((e) =>
          (function (e, t, n, o) {
            const r = {},
              i = [Ft()];
            n &&
              (e || (r.attrs = { "data-uci": n.moves[0] }),
              t > 1 && i.push(d("strong", b(n.mate) ? "#" + n.mate : he(n.cp))),
              o &&
                i.push(
                  ...(function (e, t) {
                    const n = [];
                    let o = Fe(e.board);
                    for (let r = 0; r < t.length; r++) {
                      let i;
                      "white" === e.turn
                        ? (i = `${e.fullmoves}.`)
                        : 0 === r && (i = `${e.fullmoves}...`),
                        i && n.push(d("span", { key: i }, i));
                      const s = t[r],
                        a = Mt(e, G(s)),
                        c = Fe(e.board);
                      if ("--" === a) break;
                      (o += "|" + s),
                        n.push(
                          d(
                            "span.pv-san",
                            {
                              key: o,
                              attrs: {
                                "data-move-index": r,
                                "data-board": `${c}|${s}`,
                              },
                            },
                            a
                          )
                        );
                    }
                    return n;
                  })(o.clone(), n.moves.slice(0, 16))
                ));
            return d("div.pv.pv--nowrap", r, i);
          })(c, n, i[e], l.isOk ? l.value : void 0)
        ),
        Vt(e),
      ]
    );
  }
  function Ft() {
    return d("span.pv-wrap-toggle", {
      hook: {
        insert: (e) => {
          const t = e.elm;
          for (const n of ["touchstart", "mousedown"])
            t.addEventListener(n, (e) => {
              e.stopPropagation(),
                e.preventDefault(),
                $(t).closest(".pv").toggleClass("pv--nowrap");
            });
        },
      },
    });
  }
  function Vt(e) {
    const t = e.getCeval().pvBoard();
    if (!t) return;
    const { fen: n, uci: o } = t,
      r = {
        fen: n,
        lastMove: "@" === o[1] ? [o.slice(2)] : [o.slice(0, 2), o.slice(2, 4)],
        orientation: e.getOrientation(),
        coordinates: !1,
        viewOnly: !0,
        drawable: { enabled: !1, visible: !1 },
      },
      i = d("div.cg-wrap.is2d", {
        hook: {
          insert: (e) => (e.elm._cg = window.Chessground(e.elm, r)),
          update: (e) => e.elm._cg.set(r),
          destroy: (e) => e.elm._cg.destroy(),
        },
      });
    return d("div.pv-board", d("div.pv-board-square", i));
  }
  lichess.storage.make("ceval.disable").listen(() => {
    const e = document.getElementById("analyse-toggle-ceval");
    (null == e ? void 0 : e.checked) && e.click();
  });
  const Wt = ["white", "black"],
    jt = ["a", "b", "c", "d", "e", "f", "g", "h"],
    Ut = ["1", "2", "3", "4", "5", "6", "7", "8"],
    Ht = [...Ut].reverse(),
    Gt = Array.prototype.concat(...jt.map((e) => Ut.map((t) => e + t))),
    Xt = (e) => Gt[8 * e[0] + e[1]],
    Qt = (e) => [e.charCodeAt(0) - 97, e.charCodeAt(1) - 49],
    Yt = Gt.map(Qt);
  const Jt = () => {
      let e;
      return {
        start() {
          e = performance.now();
        },
        cancel() {
          e = void 0;
        },
        stop() {
          if (!e) return 0;
          const t = performance.now() - e;
          return (e = void 0), t;
        },
      };
    },
    Zt = (e) => ("white" === e ? "black" : "white"),
    en = (e, t) => {
      const n = e[0] - t[0],
        o = e[1] - t[1];
      return n * n + o * o;
    },
    tn = (e, t) => e.role === t.role && e.color === t.color,
    nn = (e) => (t, n) =>
      [
        ((n ? t[0] : 7 - t[0]) * e.width) / 8,
        ((n ? 7 - t[1] : t[1]) * e.height) / 8,
      ],
    on = (e, t) => {
      e.style.transform = `translate(${t[0]}px,${t[1]}px)`;
    },
    rn = (e, t, n = 1) => {
      e.style.transform = `translate(${t[0]}px,${t[1]}px) scale(${n})`;
    },
    sn = (e, t) => {
      e.style.visibility = t ? "visible" : "hidden";
    },
    an = (e) => {
      var t;
      return e.clientX || 0 === e.clientX
        ? [e.clientX, e.clientY]
        : (null === (t = e.targetTouches) || void 0 === t ? void 0 : t[0])
        ? [e.targetTouches[0].clientX, e.targetTouches[0].clientY]
        : void 0;
    },
    cn = (e) => 2 === e.buttons || 2 === e.button,
    ln = (e, t) => {
      const n = document.createElement(e);
      return t && (n.className = t), n;
    };
  function un(e, t, n) {
    const o = Qt(e);
    return (
      t || ((o[0] = 7 - o[0]), (o[1] = 7 - o[1])),
      [
        n.left + (n.width * o[0]) / 8 + n.width / 16,
        n.top + (n.height * (7 - o[1])) / 8 + n.height / 16,
      ]
    );
  }
  function dn(e, t, n) {
    return [
      { orig: e.slice(0, 2), dest: e.slice(2, 4), brush: t, modifiers: n },
    ];
  }
  function hn(e) {
    return e.length / 2;
  }
  function pn(e) {
    return e.slice(0, 2);
  }
  function fn(e) {
    return e.slice(2);
  }
  function mn(e) {
    return e.slice(0, -2);
  }
  function vn(e, t) {
    return e.startsWith(t);
  }
  function gn(e) {
    let t = "";
    for (const n in e) t += e[n].id;
    return t;
  }
  function bn(e, t) {
    const n = e.children[0];
    return n ? t(n) : void 0;
  }
  function kn(e, t) {
    const n = [e];
    let o,
      r = e;
    for (; (o = t(r)); ) n.push(o), (r = o);
    return n;
  }
  function wn(e) {
    return e.children[0];
  }
  function yn(e, t) {
    return e.children.find((e) => e.id === t);
  }
  function zn(e, t) {
    e.children = e.children.filter(function (e) {
      return e.id !== t;
    });
  }
  function Sn(e, t) {
    (e.eval = t.eval),
      t.glyphs && (e.glyphs = t.glyphs),
      t.comments &&
        t.comments.forEach(function (t) {
          e.comments
            ? e.comments.some(function (e) {
                return e.text === t.text;
              }) || e.comments.push(t)
            : (e.comments = [t]);
        }),
      t.children.forEach(function (t) {
        const n = yn(e, t.id);
        n ? Sn(n, t) : e.children.push(t);
      });
  }
  function Cn(e) {
    return kn(e, wn);
  }
  function xn(e) {
    function t() {
      return (function (e, t) {
        const n = function (e) {
          return t(e) ? e : bn(e, n);
        };
        return n(e);
      })(e, (e) => !e.children.length);
    }
    function n(t) {
      return o(e, t);
    }
    function o(e, t) {
      if ("" === t) return e;
      const n = yn(e, pn(t));
      return n ? o(n, fn(t)) : e;
    }
    function r(t) {
      return i(e, t);
    }
    function i(e, t) {
      if ("" === t) return e;
      const n = yn(e, pn(t));
      return n ? i(n, fn(t)) : void 0;
    }
    function s(e, t) {
      const n = pn(t),
        o = yn(e, n);
      return o ? n + s(o, fn(t)) : "";
    }
    function a(e, t) {
      if ("" === t) return !0;
      const n = pn(t),
        o = e.children[0];
      return !(!o || o.id !== n) && a(o, fn(t));
    }
    function c(e, t) {
      if ("" === t) return e;
      const n = pn(t),
        o = e.children[0];
      return o && o.id === n ? c(o, fn(t)) : e;
    }
    function l(t) {
      return kn(e, function (e) {
        const n = pn(t);
        if ("" !== n) return (t = fn(t)), yn(e, n);
      });
    }
    function u(e, t) {
      const n = r(e);
      if (n) return t(n), n;
    }
    function d(e, t) {
      const n = t + e.id,
        o = r(n);
      return o
        ? (["dests", "drops", "clock"].forEach((t) => {
            b(e[t]) && !b(o[t]) && (o[t] = e[t]);
          }),
          n)
        : u(t, function (t) {
            t.children.push(e);
          })
        ? n
        : void 0;
    }
    function h(e, t) {
      return u(t, function (t) {
        const n = (t.comments || []).filter(function (t) {
          return t.id !== e;
        });
        t.comments = n.length ? n : void 0;
      });
    }
    function p(e) {
      return n(mn(e));
    }
    return {
      root: e,
      lastPly() {
        var n;
        return (null === (n = t()) || void 0 === n ? void 0 : n.ply) || e.ply;
      },
      nodeAtPath: n,
      getNodeList: l,
      longestValidPath: (t) => s(e, t),
      updateAt: u,
      addNode: d,
      addNodes: function e(t, n) {
        const o = t[0];
        if (!o) return n;
        const r = d(o, n);
        return r ? e(t.slice(1), r) : void 0;
      },
      addDests: (e, t) =>
        u(t, function (t) {
          t.dests = e;
        }),
      setShapes: (e, t) =>
        u(t, function (t) {
          t.shapes = e;
        }),
      setCommentAt: function (e, t) {
        return e.text
          ? u(t, function (t) {
              t.comments = t.comments || [];
              const n = t.comments.find(function (t) {
                return t.id === e.id;
              });
              n ? (n.text = e.text) : t.comments.push(e);
            })
          : h(e.id, t);
      },
      deleteCommentAt: h,
      setGlyphsAt: function (e, t) {
        return u(t, function (t) {
          t.glyphs = e;
        });
      },
      setClockAt: (e, t) =>
        u(t, function (t) {
          t.clock = e;
        }),
      pathIsMainline: function (t) {
        return a(e, t);
      },
      pathIsForcedVariation: function (e) {
        return !!l(e).find((e) => e.forceVariation);
      },
      lastMainlineNode: (t) => c(e, t),
      pathExists: function (e) {
        return !!r(e);
      },
      deleteNodeAt: function (e) {
        zn(
          p(e),
          (function (e) {
            return e.slice(-2);
          })(e)
        );
      },
      promoteAt: function (e, t) {
        const n = l(e);
        for (let o = n.length - 2; o >= 0; o--) {
          const e = n[o + 1],
            r = n[o];
          if (r.children[0].id !== e.id) {
            if ((zn(r, e.id), r.children.unshift(e), !t)) break;
          } else if (e.forceVariation && ((e.forceVariation = !1), !t)) break;
        }
      },
      forceVariationAt: (e, t) =>
        u(e, function (e) {
          e.forceVariation = t;
        }),
      getCurrentNodesAfterPly: function (e, t, n) {
        const o = [];
        for (const r in e) {
          const i = e[r];
          if (i.ply <= n && t[r].id !== i.id) break;
          i.ply > n && o.push(i);
        }
        return o;
      },
      merge(t) {
        Sn(e, t);
      },
      removeCeval() {
        !(function (e, t) {
          !(function e(n) {
            t(n), n.children.forEach(e);
          })(e);
        })(e, function (e) {
          delete e.ceval, delete e.threat;
        });
      },
      removeComputerVariations() {
        Cn(e).forEach(function (e) {
          e.children = e.children.filter(function (e) {
            return !e.comp;
          });
        });
      },
      parentNode: p,
      getParentClock: function (e, t) {
        if (!("parentClock" in e)) {
          const n = t && p(t);
          e.parentClock = n ? ("clock" in n ? n.clock : void 0) : e.clock;
        }
        return e.parentClock;
      },
    };
  }
  function En(e) {
    const t = e.vm.node.children[0];
    t && e.userJump(e.vm.path + t.id);
  }
  function Mn(e) {
    e.userJump(mn(e.vm.path));
  }
  function _n(e) {
    const t = !vn(e.vm.path, e.vm.initialPath);
    e.userJump(t ? e.vm.initialPath : gn(e.vm.mainline));
  }
  function Pn(e) {
    const t = e.vm.path !== e.vm.initialPath && vn(e.vm.path, e.vm.initialPath);
    e.userJump(t ? e.vm.initialPath : "");
  }
  function qn(e) {
    return { insert: (t) => e(t.elm) };
  }
  function An(e, t, n, o = !0) {
    return qn((r) =>
      r.addEventListener(
        e,
        (e) => {
          const o = t(e);
          return !1 === o && e.preventDefault(), null == n || n(), o;
        },
        { passive: o }
      )
    );
  }
  function On(e) {
    return { "data-icon": e };
  }
  const Rn = ["queen", "knight", "rook", "bishop"];
  class Nn {
    constructor(e, t, n, o = 1) {
      (this.withGround = e),
        (this.onCancel = t),
        (this.redraw = n),
        (this.autoQueenPref = o),
        (this.start = (e, t, n, o, r = !1) =>
          this.withGround((i) => {
            const s = i.state.pieces.get(e),
              a = s || i.state.pieces.get(t);
            return (
              "pawn" == (null == a ? void 0 : a.role) &&
              (("8" == t[1] && "black" == i.state.turnColor) ||
                ("1" == t[1] && "white" == i.state.turnColor)) &&
              (this.prePromotionRole && (null == o ? void 0 : o.premove)
                ? (this.doPromote(
                    { orig: e, dest: t, callback: n },
                    this.prePromotionRole
                  ),
                  !0)
                : (null == o ? void 0 : o.ctrlKey) ||
                  this.promoting ||
                  !(
                    3 === this.autoQueenPref ||
                    (2 === this.autoQueenPref && s) ||
                    r
                  )
                ? ((this.promoting = {
                    orig: e,
                    dest: t,
                    pre: !!s,
                    callback: n,
                  }),
                  this.redraw(),
                  !0)
                : (s
                    ? this.setPrePromotion(t, "queen")
                    : this.doPromote(
                        { orig: e, dest: t, callback: n },
                        "queen"
                      ),
                  !0))
            );
          }) || !1),
        (this.cancel = () => {
          this.cancelPrePromotion(),
            this.promoting &&
              ((this.promoting = void 0), this.onCancel(), this.redraw());
        }),
        (this.cancelPrePromotion = () => {
          this.prePromotionRole &&
            (this.withGround((e) => e.setAutoShapes([])),
            (this.prePromotionRole = void 0),
            this.redraw());
        }),
        (this.view = (e) => {
          const t = this.promoting;
          if (t)
            return (
              this.withGround((n) =>
                this.renderPromotion(
                  t.dest,
                  e ? Rn.concat("king") : Rn,
                  Zt(n.state.turnColor),
                  n.state.orientation
                )
              ) || null
            );
        });
    }
    finish(e) {
      const t = this.promoting;
      t &&
        ((this.promoting = void 0),
        t.pre ? this.setPrePromotion(t.dest, e) : this.doPromote(t, e),
        this.redraw());
    }
    doPromote(e, t) {
      this.withGround((n) =>
        (function (e, t, n) {
          const o = e.state.pieces.get(t);
          o &&
            "pawn" == o.role &&
            e.setPieces(
              new Map([[t, { color: o.color, role: n, promoted: !0 }]])
            );
        })(n, e.dest, t)
      ),
        e.callback(e.orig, e.dest, t);
    }
    setPrePromotion(e, t) {
      (this.prePromotionRole = t),
        this.withGround((n) =>
          n.setAutoShapes([
            {
              orig: e,
              piece: { color: Zt(n.state.turnColor), role: t, opacity: 0.8 },
              brush: "",
            },
          ])
        );
    }
    renderPromotion(e, t, n, o) {
      let r = 12.5 * (7 - Qt(e)[0]);
      "white" === o && (r = 87.5 - r);
      return d(
        "div#promotion-choice." + (n === o ? "top" : "bottom"),
        {
          hook: qn((e) => {
            e.addEventListener("click", this.cancel),
              (e.oncontextmenu = () => !1);
          }),
        },
        t.map((e, t) =>
          d(
            "square",
            {
              attrs: {
                style:
                  "top: " + 12.5 * (n === o ? t : 7 - t) + "%;left: " + r + "%",
              },
              hook: An("click", (t) => {
                t.stopPropagation(), this.finish(e);
              }),
            },
            [d("piece." + e + "." + n)]
          )
        )
      );
    }
  }
  const Dn = { e1a1: "e1c1", e1h1: "e1g1", e8a8: "e8c8", e8h8: "e8g8" };
  class Tn {
    constructor(e, t, n) {
      (this.theme = e),
        (this.userId = t),
        (this.streak = n),
        (this.maxSize = 100),
        (this.maxAge = 36e5),
        (this.default = () => ({
          theme: this.theme,
          rounds: [],
          at: Date.now(),
        })),
        (this.store = this.streak
          ? w(this.default())
          : ae(`puzzle.session.${this.userId || "anon"}`, this.default)),
        (this.clear = () => this.update((e) => ({ ...e, rounds: [] }))),
        (this.get = () => {
          const e = this.store();
          return e.theme == this.theme && e.at > Date.now() - this.maxAge
            ? e
            : this.default();
        }),
        (this.update = (e) => this.store(e(this.get()))),
        (this.complete = (e, t) =>
          this.update((n) => {
            const o = n.rounds.findIndex((t) => t.id == e);
            return (
              -1 == o
                ? (n.rounds.push({ id: e, result: t }),
                  n.rounds.length > this.maxSize && n.rounds.shift())
                : (n.rounds[o].result = t),
              (n.at = Date.now()),
              n
            );
          })),
        (this.setRatingDiff = (e, t) =>
          this.update(
            (n) => (
              n.rounds.forEach((n) => {
                n.id == e && (n.ratingDiff = t);
              }),
              n
            )
          )),
        (this.isNew = () => this.store().rounds.length < 2);
    }
  }
  class $n {
    constructor(e) {
      var t;
      (this.fail = !1),
        (this.onComplete = (e, t) => {
          e
            ? this.nextId()
              ? (this.data.index++,
                t && (this.data.current = { puzzle: t.puzzle, game: t.game }),
                this.store(this.data))
              : (this.store(null), lichess.reload())
            : ((this.fail = !0), this.store(null));
        }),
        (this.nextId = () => this.data.ids[this.data.index + 1]),
        (this.skip = () => {
          (this.data.skip = !1), this.store(this.data);
        }),
        (this.store = ae(
          `puzzle.streak.${
            (null === (t = e.user) || void 0 === t ? void 0 : t.id) || "anon"
          }`,
          () => null
        )),
        (this.data = this.store() || {
          ids: e.streak.split(" "),
          index: 0,
          skip: !0,
          current: { puzzle: e.puzzle, game: e.game },
        });
    }
  }
  function In(e) {
    const t = mt.default(),
      n = {
        ply: 0,
        id: "",
        fen: "r2r2k1/1p2ppbp/p5p1/q7/8/1P2BP2/1PP1Q1PP/1K1R3R b",
        children: [],
      };
    let o = n;
    return (
      e.forEach((e, n) => {
        const r = (function (e, t) {
          const n = e.ctx();
          let o;
          if (
            ("O-O" === t || "O-O+" === t || "O-O#" === t
              ? (o = "h")
              : ("O-O-O" !== t && "O-O-O+" !== t && "O-O-O#" !== t) ||
                (o = "a"),
            o)
          ) {
            const t = e.castles.rook[e.turn][o];
            if (!B(n.king) || !B(t) || !e.dests(n.king, n).has(t)) return;
            return { from: n.king, to: t };
          }
          const r = t.match(
            /^([NBRQK])?([a-h])?([1-8])?[-x]?([a-h][1-8])(?:=?([nbrqkNBRQK]))?[+#]?$/
          );
          if (!r) {
            const o = t.match(/^([pnbrqkPNBRQK])?@([a-h][1-8])[+#]?$/);
            if (!o) return;
            const r = { role: j(o[1]) || "pawn", to: U(o[2]) };
            return e.isLegal(r, n) ? r : void 0;
          }
          const i = j(r[1]) || "pawn",
            s = U(r[4]),
            a = j(r[5]);
          if (!!a !== ("pawn" === i && _e.backranks().has(s))) return;
          if ("king" === a && "antichess" !== e.rules) return;
          let c = e.board.pieces(e.turn, i);
          r[2] &&
            (c = c.intersect(
              _e.fromFile(r[2].charCodeAt(0) - "a".charCodeAt(0))
            )),
            r[3] &&
              (c = c.intersect(
                _e.fromRank(r[3].charCodeAt(0) - "1".charCodeAt(0))
              ));
          const l = "pawn" === i ? _e.fromFile(V(s)) : _e.empty();
          let u;
          c = c.intersect(
            l.union(ct({ color: K(e.turn), role: i }, s, e.board.occupied))
          );
          for (const d of c)
            if (e.dests(d, n).has(s)) {
              if (B(u)) return;
              u = d;
            }
          return B(u) ? { from: u, to: s, promotion: a } : void 0;
        })(t, e);
        if (!!r) t.play(r);
        const i = Bn(t, r, n + 1, e);
        o.children.push(i), (o = i);
      }),
      n
    );
  }
  function Ln(e, t, n, o) {
    const r = e.nodeAtPath(t),
      i = mt.fromSetup(Be(r.fen).unwrap()).unwrap(),
      s = r.ply,
      a = n.map((e, t) => {
        const n = i.normalizeMove(G(e)),
          r = (function (e, t) {
            return Mt(e.clone(), t);
          })(i, n);
        i.play(n);
        const a = Bn(i, n, s + t + 1, r);
        return ("white" == o) == (a.ply % 2 == 1) && (a.puzzle = "good"), a;
      });
    e.addNodes(a, t);
  }
  const Bn = (e, t, n, o) => ({
    ply: n,
    san: o,
    fen: je(e.toSetup()),
    id: Y(t),
    uci: X(t),
    check: e.isCheck() ? H(e.toSetup().board.kingOf(e.turn)) : void 0,
    children: [],
  });
  function Kn(e, t) {
    var n;
    const o = { next: Z() };
    let r, i, s;
    const a = !!e.data.streak,
      c = se("puzzle.autoNext" + (a ? ".streak" : ""), a),
      l = se("puzzle.rated", !0),
      u = w(void 0),
      d = w(!1),
      h = e.data.streak ? new $n(e.data) : void 0,
      p = lichess.storage.make("puzzle.streak.fail");
    h && ((e.data = { ...e.data, ...h.data.current }), p.listen((e) => F(h)));
    const f = new Tn(
      e.data.theme.key,
      null === (n = e.data.user) || void 0 === n ? void 0 : n.id,
      a
    );
    (o.showComputer = () => "view" === o.mode), (o.showAutoShapes = () => !0);
    const m = (e) => P(100, () => lichess.sound.play(e)),
      k = (e, t, n) => (
        setTimeout(
          () =>
            lichess.sound.loadOggOrMp3(e, `${lichess.sound.baseUrl}/${e}`, !0),
          n || 1e3
        ),
        () => lichess.sound.play(e, t)
      ),
      y = {
        move: m("move"),
        capture: m("capture"),
        check: m("check"),
        good: k("PuzzleStormGood", 0.7, 500),
        end: k("PuzzleStormEnd", 1, 1e3),
      };
    let z = !1;
    function S(e) {
      var t;
      (o.path = e),
        (o.nodeList = i.getNodeList(e)),
        (o.node = (t = o.nodeList)[t.length - 1]),
        (o.mainline = Cn(i.root));
    }
    function C(e) {
      const t = u();
      return t && e(t);
    }
    function E(e) {
      (r = e), (i = xn(In(r.game.pgn.split(" "))));
      const n = gn(Cn(i.root));
      (o.mode = "play"),
        (o.next = Z()),
        (o.round = void 0),
        (o.justPlayed = void 0),
        (o.resultSent = !1),
        (o.lastFeedback = "init"),
        (o.initialPath = n),
        (o.initialNode = i.nodeAtPath(n)),
        (o.pov = o.initialNode.ply % 2 == 1 ? "black" : "white"),
        S(lichess.PuzzleNVUI ? n : mn(n)),
        setTimeout(() => {
          ae(n), t();
        }, 500),
        (o.canViewSolution = !1),
        setTimeout(() => {
          (o.canViewSolution = !0), t();
        }, 4e3),
        C((e) => {
          e.setAutoShapes([]), e.setShapes([]), R(e);
        }),
        (function () {
          s && s.destroy();
          s = Et({
            redraw: t,
            storageKeyPrefix: "puzzle",
            multiPvDefault: 3,
            variant: { short: "Std", name: "Standard", key: "standard" },
            initialFen: void 0,
            possible: !0,
            emit: function (e, n) {
              i.updateAt(n.path, function (r) {
                var i;
                if (n.threatMode) {
                  const t = e;
                  (!r.threat ||
                    r.threat.depth <= t.depth ||
                    r.threat.maxDepth < t.maxDepth) &&
                    (r.threat = t);
                } else (!r.ceval || r.ceval.depth <= e.depth || (null !== (i = r.ceval.maxDepth) && void 0 !== i ? i : 0) < e.maxDepth) && (r.ceval = e);
                n.path === o.path && (Q(), t());
              });
            },
            setAutoShapes: Q,
          });
        })();
    }
    function M() {
      const e = Be(o.node.fen).unwrap();
      return mt.fromSetup(e).unwrap();
    }
    function O() {
      const e = o.node,
        t = e.ply % 2 == 0 ? "white" : "black",
        n = (function (e, t) {
          const n = new Map(),
            o = e.ctx();
          for (const [r, i] of e.allDests(o))
            if (i.nonEmpty()) {
              const e = Array.from(i, H);
              (null == t ? void 0 : t.chess960) ||
                r !== o.king ||
                4 !== V(r) ||
                (i.has(0) ? e.push("c1") : i.has(56) && e.push("c8"),
                i.has(7) ? e.push("g1") : i.has(63) && e.push("g8")),
                n.set(H(r), e);
            }
          return n;
        })(M()),
        r = o.node.children[0],
        i =
          "view" === o.mode || (t === o.pov && (!r || "fail" == r.puzzle))
            ? { color: n.size > 0 ? t : void 0, dests: n }
            : { color: void 0, dests: new Map() },
        s = {
          fen: e.fen,
          orientation: z ? K(o.pov) : o.pov,
          turnColor: t,
          movable: i,
          premovable: { enabled: !1 },
          check: !!e.check,
          lastMove:
            ((a = e.uci), b(a) ? [a.substr(0, 2), a.substr(2, 2)] : void 0),
        };
      var a;
      return (
        e.ply >= o.initialNode.ply &&
          ("view" === o.mode ||
            t === o.pov ||
            r ||
            ((s.movable.color = o.pov), (s.premovable.enabled = !0))),
        (o.cgConfig = s),
        s
      );
    }
    function R(e) {
      e.set(O());
    }
    function N(e) {
      T(G(e));
    }
    function D(e, t, n) {
      T({ from: U(e), to: U(t), promotion: n });
    }
    function T(e) {
      I(o.path, M(), e);
    }
    function I(n, s, a) {
      a = s.normalizeMove(a);
      const l = Mt(s, a),
        u = s.isCheck() ? s.board.kingOf(s.turn) : void 0;
      !(function (n, s) {
        ae(i.addNode(n, s)), C((e) => e.playPremove());
        const a = (function (e, t) {
          if ("view" === e.mode) return;
          if (!vn(e.path, e.initialPath)) return;
          if ((e.node.ply % 2 == 1 ? "white" : "black") !== e.pov) return;
          const n = e.nodeList
            .slice(hn(e.initialPath) + 1)
            .map((e) => ({
              uci: e.uci,
              castle: e.san.startsWith("O-O"),
              checkmate: e.san.endsWith("#"),
            }));
          for (const i in n) {
            if (n[i].checkmate) return (e.node.puzzle = "win");
            const r = n[i].uci,
              s = t.solution[i];
            if (!(r == s || (n[i].castle && ((o = r), o in Dn) && Dn[r] == s)))
              return (e.node.puzzle = "fail");
          }
          var o;
          const r = t.solution[n.length];
          return r
            ? ((e.node.puzzle = "good"),
              { move: G(r), fen: e.node.fen, path: e.path })
            : (e.node.puzzle = "win");
        })(o, r.puzzle);
        a &&
          (function (t) {
            if ("fail" === t)
              (o.lastFeedback = "fail"),
                lichess.PuzzleNVUI ? B() : setTimeout(B, 100),
                "play" === o.mode &&
                  (h
                    ? (F(h), p.fire())
                    : ((o.canViewSolution = !0), (o.mode = "try"), W(!1)));
            else if ("win" == t) {
              if ((h && y.good(), (o.lastFeedback = "win"), "view" != o.mode)) {
                const e = "play" == o.mode ? W(!0) : Promise.resolve();
                (o.mode = "view"), C(R), e.then((e) => (c() ? j() : J()));
              }
            } else
              t &&
                ((o.lastFeedback = "good"),
                setTimeout(() => {
                  const e = mt.fromSetup(Be(t.fen).unwrap()).unwrap();
                  I(t.path, e, t.move);
                }, e.pref.animation.duration * (c() ? 1 : 1.5)));
          })(a);
        L(s), t(), g(n, !1);
      })(
        {
          ply: 2 * (s.fullmoves - 1) + ("white" == s.turn ? 0 : 1),
          fen: je(s.toSetup()),
          id: Y(a),
          uci: X(a),
          san: l,
          check: b(u) ? H(u) : void 0,
          children: [],
        },
        n
      );
    }
    function L(e, t) {
      const n = i.nodeAtPath(e);
      n.children.sort((e, t) => {
        const n = e.puzzle;
        return "fail" == n ? 1 : "good" == n || "win" == n ? -1 : 0;
      }),
        t && n.children.forEach((t) => L(e + t.id, !0));
    }
    function B() {
      C((e) => e.cancelPremove()), ce(mn(o.path)), t();
    }
    function F(e) {
      (o.mode = "view"), e.onComplete(!1), setTimeout(le, 500), y.end();
    }
    async function W(e) {
      var n;
      if (o.resultSent) return Promise.resolve();
      (o.resultSent = !0), f.complete(r.puzzle.id, e);
      // const i = await (function (e, t, n, o, r, i) {
      //     return x(`/training/complete/${t}/${e}`, { method: "POST", body: _({ win: n, ...(r ? { replayDays: r.days } : {}), ...(i ? { streakId: i.nextId(), streakScore: i.data.index } : {}), rated: o() }) });
      // })(r.puzzle.id, r.theme.key, e, l, r.replay, h);
      // if (i.replayComplete && r.replay) return lichess.redirect(`/training/dashboard/${r.replay.days}`);
      // i.next.user &&
      //     r.user &&
      //     ((r.user.rating = i.next.user.rating),
      //     (r.user.provisional = i.next.user.provisional),
      //     (o.round = i.round),
      //     (null === (n = i.round) || void 0 === n ? void 0 : n.ratingDiff) && f.setRatingDiff(r.puzzle.id, i.round.ratingDiff)),
      //     e && lichess.sound.say("Success!"),
      //     o.next.resolve(i.next),
      //     h && e && h.onComplete(!0, i.next),
      //     t(); Alterado por mim
    }
    function j() {
      if ((s.stop(), o.next.promise.then(E).then(t), !h && !r.replay)) {
        const e = `/training/${r.theme.key}`;
        location.pathname != e && history.replaceState(null, "", e);
      }
    }
    function Q() {
      C((e) => {
        e.setAutoShapes(
          (function (e) {
            const t = e.vm.node,
              n = e.ceval.hovering(),
              o = e.ground.state.movable.color;
            let r = [];
            if (
              (n && n.fen === t.fen && (r = r.concat(dn(n.uci, "paleBlue"))),
              e.vm.showAutoShapes() &&
                e.vm.showComputer() &&
                (t.eval && (r = r.concat(dn(t.eval.best, "paleGreen"))), !n))
            ) {
              let n = e.nextNodeBest;
              !n &&
                e.ceval.enabled() &&
                t.ceval &&
                (n = t.ceval.pvs[0].moves[0]),
                n && (r = r.concat(dn(n, "paleBlue"))),
                e.ceval.enabled() &&
                  t.ceval &&
                  t.ceval.pvs &&
                  t.ceval.pvs[1] &&
                  !(e.threatMode && t.threat && t.threat.pvs[2]) &&
                  t.ceval.pvs.forEach(function (e) {
                    if (e.moves[0] === n) return;
                    const i = de(o, t.ceval.pvs[0], e);
                    i > 0.2 ||
                      isNaN(i) ||
                      i < 0 ||
                      (r = r.concat(
                        dn(e.moves[0], "paleGrey", {
                          lineWidth: Math.round(12 - 50 * i),
                        })
                      ));
                  });
            }
            return (
              e.ceval.enabled() &&
                e.threatMode &&
                t.threat &&
                (t.threat.pvs[1]
                  ? ((r = r.concat(dn(t.threat.pvs[0].moves[0], "paleRed"))),
                    t.threat.pvs.slice(1).forEach(function (e) {
                      const n = de(Zt(o), e, t.threat.pvs[0]);
                      n > 0.2 ||
                        isNaN(n) ||
                        n < 0 ||
                        (r = r.concat(
                          dn(e.moves[0], "paleRed", {
                            lineWidth: Math.round(11 - 45 * n),
                          })
                        ));
                    }))
                  : (r = r.concat(dn(t.threat.pvs[0].moves[0], "red")))),
              r
            );
          })({
            vm: o,
            ceval: s,
            ground: e,
            threatMode: d(),
            nextNodeBest: te(),
          })
        );
      });
    }
    function J() {
      s.enabled() && "view" === o.mode && !ie() && ee();
    }
    const ee = P(800, function () {
        s.start(o.path, o.nodeList, d());
      }),
      te = () =>
        bn(o.node, (e) => {
          var t;
          return null === (t = e.eval) || void 0 === t ? void 0 : t.best;
        }),
      ne = () => s;
    function oe() {
      s.toggle(),
        Q(),
        J(),
        s.enabled() || d(!1),
        (o.autoScrollRequested = !0),
        t();
    }
    function re() {
      o.node.check ||
        (s.enabled() || s.toggle(), s.enabled() && (d(!d()), Q(), J(), t()));
    }
    function ie() {
      return M().outcome();
    }
    function ae(e) {
      const t = e !== o.path,
        n = t && e.length === o.path.length + 2;
      S(e),
        C(R),
        t &&
          (n &&
            (o.node.uci
              ? (o.justPlayed && !o.node.uci.includes(o.justPlayed)) ||
                (o.node.san.includes("x") ? y.capture() : y.move())
              : y.move(),
            /\+|#/.test(o.node.san) && y.check()),
          d(!1),
          s.stop(),
          J()),
        he.cancel(),
        (o.justPlayed = void 0),
        (o.autoScrollRequested = !0),
        lichess.pubsub.emit("ply", o.node.ply);
    }
    function ce(e) {
      var t;
      ("fail" ==
        (null === (t = i.nodeAtPath(e)) || void 0 === t ? void 0 : t.puzzle) &&
        "view" != o.mode) ||
        (C((e) => e.selectSquare(null)), ae(e), g(o.node, !0));
    }
    function le() {
      W(!1),
        (o.mode = "view"),
        Ln(i, o.initialPath, r.puzzle.solution, o.pov),
        L(o.initialPath, !0);
      const e = o.node.children[0];
      if (e && "good" === e.puzzle) ce(o.path + e.id);
      else {
        const e = (function (e, t) {
          let n = "";
          for (const o in e) {
            if (!t(e[o])) break;
            n += e[o].id;
          }
          return n;
        })(o.mainline, (e) => "good" != e.puzzle);
        e && ce(e + i.nodeAtPath(e).children[0].id);
      }
      (o.autoScrollRequested = !0),
        (o.voteDisabled = !0),
        t(),
        J(),
        setTimeout(() => {
          (o.voteDisabled = !1), t();
        }, 500);
    }
    const ue = () => {
      (z = !z), C((e) => e.toggleOrientation()), t();
    };
    E(e.data);
    const he = new Nn(C, () => C((e) => e.set(o.cgConfig)), t);
    function pe() {
      const e = te() || (o.node.ceval && o.node.ceval.pvs[0].moves[0]);
      e && N(e);
    }
    var fe;
    return (
      (fe = {
        vm: o,
        userJump: ce,
        getCeval: ne,
        toggleCeval: oe,
        toggleThreatMode: re,
        redraw: t,
        playBestMove: pe,
        flip: ue,
        flipped: () => z,
      }),
      window.Mousetrap.bind(["left", "k"], () => {
        Mn(fe), fe.redraw();
      })
        .bind(["right", "j"], () => {
          En(fe), fe.redraw();
        })
        .bind(["up", "0"], () => {
          Pn(fe), fe.redraw();
        })
        .bind(["down", "$"], () => {
          _n(fe), fe.redraw();
        })
        .bind("l", fe.toggleCeval)
        .bind("x", fe.toggleThreatMode)
        .bind("space", () => {
          "view" === fe.vm.mode &&
            (fe.getCeval().enabled() ? fe.playBestMove() : fe.toggleCeval());
        })
        .bind("z", () => lichess.pubsub.emit("zen"))
        .bind("f", fe.flip),
      document.addEventListener("visibilitychange", () =>
        lichess.requestIdleCallback(() => ae(o.path), 500)
      ),
      lichess.pubsub.on("speech.enabled", v),
      v(lichess.sound.speech()),
      lichess.pubsub.on("zen", () => {
        const e = $("body").toggleClass("zen").hasClass("zen");
        window.dispatchEvent(new Event("resize")), A(e);
      }),
      $("body").addClass("playing"),
      $("#zentog").on("click", () => lichess.pubsub.emit("zen")),
      {
        vm: o,
        getData: () => r,
        getTree: () => i,
        ground: u,
        makeCgOpts: O,
        userJump: ce,
        viewSolution: le,
        nextPuzzle: j,
        vote: (e) => {
          o.voteDisabled ||
            (!(function (e, t) {
              x(`/training/${e}/vote`, {
                method: "POST",
                body: _({ vote: t }),
              });
            })(r.puzzle.id, e),
            j());
        },
        voteTheme: (e, n) => {
          o.round &&
            ((o.round.themes = o.round.themes || {}),
            n === o.round.themes[e]
              ? (delete o.round.themes[e], q(r.puzzle.id, e, void 0))
              : (n || r.puzzle.themes.includes(e)
                  ? (o.round.themes[e] = n)
                  : delete o.round.themes[e],
                q(r.puzzle.id, e, n)),
            t());
        },
        getCeval: ne,
        pref: e.pref,
        difficulty: e.difficulty,
        trans: lichess.trans(e.i18n),
        autoNext: c,
        autoNexting: () => "win" == o.lastFeedback && c(),
        rated: l,
        toggleRated: () => {
          l(!l()), t();
        },
        outcome: ie,
        toggleCeval: oe,
        toggleThreatMode: re,
        threatMode: d,
        currentEvals: () => ({ client: o.node.ceval }),
        nextNodeBest: te,
        userMove: function (e, t) {
          (o.justPlayed = e), he.start(e, t, D) || D(e, t);
        },
        playUci: N,
        playUciList: function (e) {
          e.forEach(N);
        },
        showEvalGauge: () => o.showComputer() && s.enabled() && !ie(),
        getOrientation: () => C((e) => e.state.orientation),
        getNode: () => o.node,
        showComputer: o.showComputer,
        promotion: he,
        redraw: t,
        ongoing: !1,
        playBestMove: pe,
        session: f,
        allThemes: e.themes && {
          dynamic: e.themes.dynamic.split(" "),
          static: new Set(e.themes.static.split(" ")),
        },
        streak: h,
        skip: () => {
          if (!h || !h.data.skip || "play" != o.mode) return;
          h.skip(), ce(gn(o.mainline));
          const e = hn(o.path) - hn(o.initialPath);
          N(r.puzzle.solution[e]), pe();
        },
        flip: ue,
        flipped: () => z,
        showRatings: e.showRatings,
        nvui: lichess.PuzzleNVUI ? lichess.PuzzleNVUI(t) : void 0,
      }
    );
  }
  let Fn = !1;
  const Vn = (e) => (
    !1 === Fn &&
      (Fn = window.Intl && Intl.NumberFormat ? new Intl.NumberFormat() : null),
    null === Fn ? "" + e : Fn.format(e)
  );
  function Wn(e) {
    const t = e.getData();
    return d("div.puzzle__side__metas", [
      jn(e, t.puzzle),
      Un(e, t.game, t.puzzle),
    ]);
  }
  function jn(e, t) {
    return d("div.infos.puzzle", { attrs: On("") }, [
      d("div", [
        e.streak
          ? null
          : d(
              "p",
              e.trans.vdom(
                "puzzleId",
                d(
                  "a",
                  {
                    attrs: {
                      href: `/training/${t.id}`,
                      ...(e.streak
                        ? { target: "_blank", rel: "noopener" }
                        : {}),
                    },
                  },
                  "#" + t.id
                )
              )
            ),
        e.showRatings
          ? d(
              "p",
              e.trans.vdom(
                "ratingX",
                e.streak || "play" !== e.vm.mode
                  ? d("strong", t.rating)
                  : d("span.hidden", e.trans.noarg("hidden"))
              )
            )
          : null,
        d("p", e.trans.vdom("playedXTimes", d("strong", Vn(t.plays)))),
      ]),
    ]);
  }
  function Un(e, t, n) {
    const o = `${t.clock} • ${t.perf.name}`;
    return d("div.infos", { attrs: On(t.perf.icon) }, [
      d("div", [
        d(
          "p",
          e.trans.vdom(
            "fromGameLink",
            "play" == e.vm.mode
              ? d("span", o)
              : d(
                  "a",
                  { attrs: { href: `/${t.id}/${e.vm.pov}#${n.initialPly}` } },
                  o
                )
          )
        ),
        d(
          "div.players",
          t.players.map((t) => {
            const n = e.showRatings ? t.name : t.name.split(" ")[0];
            return d(
              "div.player.color-icon.is.text." + t.color,
              "anon" != t.userId
                ? d(
                    "a.user-link.ulpt",
                    { attrs: { href: "/@/" + t.userId } },
                    t.title && "BOT" != t.title
                      ? [d("span.utitle", t.title), " " + n]
                      : n
                  )
                : n
            );
          })
        ),
      ]),
    ]);
  }
  const Hn = (e) => {
      var t;
      const n = e.getData(),
        o = e.trans.noarg;
      if (!n.user)
        return d("div.puzzle__side__user", [
          d("p", o("toGetPersonalizedPuzzles")),
          d("a.button", { attrs: { href: "/signup" } }, o("signUp")),
        ]);
      const r =
          null === (t = e.vm.round) || void 0 === t ? void 0 : t.ratingDiff,
        i = "puzzle-toggle-rated";
      return d("div.puzzle__side__user", [
        n.replay || e.streak || !n.user
          ? void 0
          : d("div.puzzle__side__config__toggle", [
              d("div.switch", [
                d(`input#${i}.cmn-toggle.cmn-toggle--subtle`, {
                  attrs: {
                    type: "checkbox",
                    checked: e.rated(),
                    disabled: "init" != e.vm.lastFeedback,
                  },
                  hook: {
                    insert: (t) =>
                      t.elm.addEventListener("change", e.toggleRated),
                  },
                }),
                d("label", { attrs: { for: i } }),
              ]),
              d("label", { attrs: { for: i } }, o("rated")),
            ]),
        d(
          "div.puzzle__side__user__rating",
          e.rated()
            ? e.showRatings
              ? d("strong", [
                  n.user.rating - (r || 0),
                  ...(r && r > 0 ? [" ", d("good.rp", "+" + r)] : []),
                  ...(r && r < 0 ? [" ", d("bad.rp", "−" + -r)] : []),
                ])
              : null
            : d(
                "p.puzzle__side__user__rating__casual",
                o("yourPuzzleRatingWillNotChange")
              )
        ),
      ]);
    },
    Gn = (e) => {
      return d(
        "div.puzzle__side__user",
        ((t = e.streak),
        (n = e.trans.noarg),
        d(
          "div.puzzle__side__streak",
          0 == t.data.index
            ? d("div.puzzle__side__streak__info", [
                d("h1.text", { attrs: On("") }, "Puzzle Streak"),
                d("p", n("streakDescription")),
              ])
            : d(
                "div.puzzle__side__streak__score.text",
                { attrs: On("") },
                t.data.index
              )
        ))
      );
      var t, n;
    },
    Xn = [
      ["easiest", -600],
      ["easier", -300],
      ["normal", 0],
      ["harder", 300],
      ["hardest", 600],
    ];
  function Qn(e) {
    const t = e.getData().replay;
    if (!t) return;
    const n = t.i + ("play" == e.vm.mode ? 0 : 1);
    return d("div.puzzle__side__replay", [
      d("a", { attrs: { href: `/training/dashboard/${t.days}` } }, [
        "« ",
        `Replaying ${e.trans.noarg(e.getData().theme.key)} puzzles`,
      ]),
      d("div.puzzle__side__replay__bar", {
        attrs: {
          style: `--p:${t.of ? Math.round((100 * n) / t.of) : 1}%`,
          "data-text": `${n} / ${t.of}`,
        },
      }),
    ]);
  }
  function Yn(e) {
    const t = "puzzle-toggle-autonext",
      n = e.trans.noarg,
      o = e.getData();
    return d("div.puzzle__side__config", [
      d("div.puzzle__side__config__toggle", [
        d("div.switch", [
          d(`input#${t}.cmn-toggle.cmn-toggle--subtle`, {
            attrs: { type: "checkbox", checked: e.autoNext() },
            hook: {
              insert: (t) =>
                t.elm.addEventListener("change", () => {
                  e.autoNext(!e.autoNext()),
                    e.autoNext() && e.vm.resultSent && e.nextPuzzle();
                }),
            },
          }),
          d("label", { attrs: { for: t } }),
        ]),
        d("label", { attrs: { for: t } }, n("jumpToNextPuzzleImmediately")),
      ]),
      o.replay || e.streak || !e.difficulty ? null : Jn(e),
      d("div.puzzle__side__config__toggles", [
        d(
          "a.puzzle__side__config__zen.button.button-empty",
          {
            hook: An("click", () => lichess.pubsub.emit("zen")),
            attrs: { title: "Keyboard: z" },
          },
          n("zenMode")
        ),
        d(
          "a.puzzle__side__config__flip.button",
          {
            class: { active: e.flipped(), "button-empty": !e.flipped() },
            hook: An("click", e.flip),
            attrs: { title: "Keyboard: f" },
          },
          n("flipBoard")
        ),
      ]),
    ]);
  }
  function Jn(e) {
    return d(
      "form.puzzle__side__config__difficulty",
      {
        attrs: {
          action: `/training/difficulty/${e.getData().theme.key}`,
          method: "post",
        },
      },
      [
        d(
          "label",
          { attrs: { for: "puzzle-difficulty" } },
          e.trans.noarg("difficultyLevel")
        ),
        d(
          "select#puzzle-difficulty.puzzle__difficulty__selector",
          {
            attrs: { name: "difficulty" },
            hook: qn((e) =>
              e.addEventListener("change", () => e.parentNode.submit())
            ),
          },
          Xn.map(([t, n]) =>
            d(
              "option",
              {
                attrs: {
                  value: t,
                  selected: t == e.difficulty,
                  title:
                    !!n &&
                    e.trans.plural(
                      n < 0
                        ? "nbPointsBelowYourPuzzleRating"
                        : "nbPointsAboveYourPuzzleRating",
                      Math.abs(n)
                    ),
                },
              },
              [e.trans.noarg(t), n ? ` (${n > 0 ? "+" : ""}${n})` : ""]
            )
          )
        ),
      ]
    );
  }
  const Zn = "https://lichess.org/study/viiWlKjv";
  function eo(e) {
    const t = e.getData().theme,
      n = "view" == e.vm.mode && !e.autoNexting();
    return e.getData().replay
      ? n
        ? d("div.puzzle__side__theme", no(e))
        : null
      : e.streak
      ? null
      : d("div.puzzle__side__theme", [
          d(
            "a",
            { attrs: { href: "/training/themes" } },
            d("h2", ["« ", t.name])
          ),
          d("p", [
            t.desc,
            t.chapter &&
              d(
                "a.puzzle__side__theme__chapter.text",
                {
                  attrs: {
                    href: `${Zn}/${t.chapter}`,
                    target: "_blank",
                    rel: "noopener",
                  },
                },
                [" ", e.trans.noarg("example")]
              ),
          ]),
          n ? d("div.puzzle__themes", no(e)) : null,
        ]);
  }
  const to = new Set(["master", "masterVsMaster", "superGM"]),
    no = (e) => {
      var t;
      const n = e.getData(),
        o = e.trans.noarg,
        r =
          (null === (t = e.vm.round) || void 0 === t ? void 0 : t.themes) || {},
        i = n.puzzle.themes
          .filter((e) => !to.has(e))
          .concat(
            Object.keys(r).filter((e) => r[e] && !n.puzzle.themes.includes(e))
          )
          .sort(),
        s = "/training/daily" == location.pathname ? null : e.allThemes,
        a = s ? s.dynamic.filter((e) => !r[e]) : null;
      return (
        a && a.sort((e, t) => (o(e) < o(t) ? -1 : 1)),
        [
          d(
            "div.puzzle__themes_list",
            {
              hook: An("click", (t) => {
                const n = t.target,
                  o = n.getAttribute("data-theme");
                o && e.voteTheme(o, n.classList.contains("vote-up"));
              }),
            },
            i.map((e) =>
              d(
                "div.puzzle__themes__list__entry",
                { class: { strike: !1 === r[e] } },
                [
                  d(
                    "a",
                    {
                      attrs: {
                        href: `/training/${e}`,
                        title: o(`${e}Description`),
                      },
                    },
                    o(e)
                  ),
                  s
                    ? d(
                        "div.puzzle__themes__votes",
                        s.static.has(e)
                          ? [
                              d(
                                "div.puzzle__themes__lock",
                                d("i", { attrs: On("") })
                              ),
                            ]
                          : [
                              d("span.puzzle__themes__vote.vote-up", {
                                class: { active: r[e] },
                                attrs: { "data-theme": e },
                              }),
                              d("span.puzzle__themes__vote.vote-down", {
                                class: { active: !1 === r[e] },
                                attrs: { "data-theme": e },
                              }),
                            ]
                      )
                    : null,
                ]
              )
            )
          ),
          ...(a
            ? [
                d(
                  `select.puzzle__themes__selector.cache-bust-${a.length}`,
                  {
                    hook: {
                      ...An("change", (t) => {
                        const n = t.target.value;
                        n && e.voteTheme(n, !0);
                      }),
                      postpatch(e, t) {
                        t.elm.value = "";
                      },
                    },
                  },
                  [
                    d(
                      "option",
                      { attrs: { value: "", selected: !0 } },
                      o("addAnotherTheme")
                    ),
                    ...a.map((e) =>
                      d(
                        "option",
                        { attrs: { value: e, title: o(`${e}Description`) } },
                        o(e)
                      )
                    ),
                  ]
                ),
                d(
                  "a.puzzle__themes__study.text",
                  {
                    attrs: {
                      "data-icon": "",
                      href: Zn,
                      target: "_blank",
                      rel: "noopener",
                    },
                  },
                  "About puzzle themes"
                ),
              ]
            : []),
        ]
      );
    };
  function oo(e, t, n, o) {
    if (0 === t) return;
    const r = document.createElement("cg-resize");
    e.container.appendChild(r);
    const i = (e) => {
      e.preventDefault();
      const t = "touchstart" === e.type ? "touchmove" : "mousemove",
        n = "touchstart" === e.type ? "touchend" : "mouseup",
        o = ro(e),
        r = parseInt(
          getComputedStyle(document.body).getPropertyValue("--zoom")
        );
      let i = r;
      const s = (function (e, t, n = !1) {
          let o,
            r = 0;
          return function (...i) {
            const s = this;
            o && clearTimeout(o), (o = void 0);
            const a = performance.now() - r;
            (r = performance.now()),
              n && a > t
                ? e.apply(s, i)
                : (o = setTimeout(() => {
                    (o = void 0), e.apply(s, i);
                  }, t));
          };
        })(() => E(`/pref/zoom?v=${i}`, { method: "post" }), 700),
        a = (e) => {
          const t = ro(e),
            n = t[0] - o[0] + t[1] - o[1];
          (i = Math.round(Math.min(100, Math.max(0, r + n / 10)))),
            document.body.setAttribute("style", "--zoom:" + i),
            window.dispatchEvent(new Event("resize")),
            s();
        };
      document.body.classList.add("resizing"),
        document.addEventListener(t, a),
        document.addEventListener(
          n,
          () => {
            document.removeEventListener(t, a),
              document.body.classList.remove("resizing");
          },
          { once: !0 }
        );
    };
    if (
      (r.addEventListener("touchstart", i, { passive: !1 }),
      r.addEventListener("mousedown", i, { passive: !1 }),
      1 === t)
    ) {
      const e = (e) => r.classList.toggle("none", o ? !o(e) : e >= 2);
      e(n), lichess.pubsub.on("ply", e);
    }
  }
  function ro(e) {
    var t;
    return e.clientX || 0 === e.clientX
      ? [e.clientX, e.clientY]
      : (null === (t = e.targetTouches) || void 0 === t ? void 0 : t[0])
      ? [e.targetTouches[0].clientX, e.targetTouches[0].clientY]
      : void 0;
  }
  function io(e, t) {
    return Math.abs(e - t);
  }
  const so = (e, t, n, o) => {
      const r = io(e, n),
        i = io(t, o);
      return (1 === r && 2 === i) || (2 === r && 1 === i);
    },
    ao = (e, t, n, o) => io(e, n) === io(t, o),
    co = (e, t, n, o) => e === n || t === o,
    lo = (e, t, n, o) => ao(e, t, n, o) || co(e, t, n, o);
  function uo(e, t, n) {
    const o = e.get(t);
    if (!o) return [];
    const r = Qt(t),
      i = o.role,
      s =
        "pawn" === i
          ? ((a = o.color),
            (e, t, n, o) =>
              io(e, n) < 2 &&
              ("white" === a
                ? o === t + 1 || (t <= 1 && o === t + 2 && e === n)
                : o === t - 1 || (t >= 6 && o === t - 2 && e === n)))
          : "knight" === i
          ? so
          : "bishop" === i
          ? ao
          : "rook" === i
          ? co
          : "queen" === i
          ? lo
          : (function (e, t, n) {
              return (o, r, i, s) =>
                (io(o, i) < 2 && io(r, s) < 2) ||
                (n &&
                  r === s &&
                  r === ("white" === e ? 0 : 7) &&
                  ((4 === o &&
                    ((2 === i && t.includes(0)) ||
                      (6 === i && t.includes(7)))) ||
                    t.includes(i)));
            })(
              o.color,
              (function (e, t) {
                const n = "white" === t ? "1" : "8",
                  o = [];
                for (const [r, i] of e)
                  r[1] === n &&
                    i.color === t &&
                    "rook" === i.role &&
                    o.push(Qt(r)[0]);
                return o;
              })(e, o.color),
              n
            );
    var a;
    return Yt.filter(
      (e) => (r[0] !== e[0] || r[1] !== e[1]) && s(r[0], r[1], e[0], e[1])
    ).map(Xt);
  }
  function ho(e, ...t) {
    e && setTimeout(() => e(...t), 1);
  }
  function po(e) {
    e.premovable.current &&
      ((e.premovable.current = void 0), ho(e.premovable.events.unset));
  }
  function fo(e) {
    const t = e.predroppable;
    t.current && ((t.current = void 0), ho(t.events.unset));
  }
  function mo(e, t, n) {
    const o = e.pieces.get(t),
      r = e.pieces.get(n);
    if (t === n || !o) return !1;
    const i = r && r.color !== o.color ? r : void 0;
    return (
      n === e.selected && zo(e),
      ho(e.events.move, t, n, i),
      (function (e, t, n) {
        if (!e.autoCastle) return !1;
        const o = e.pieces.get(t);
        if (!o || "king" !== o.role) return !1;
        const r = Qt(t),
          i = Qt(n);
        if ((0 !== r[1] && 7 !== r[1]) || r[1] !== i[1]) return !1;
        4 !== r[0] ||
          e.pieces.has(n) ||
          (6 === i[0]
            ? (n = Xt([7, i[1]]))
            : 2 === i[0] && (n = Xt([0, i[1]])));
        const s = e.pieces.get(n);
        return !(
          !s ||
          s.color !== o.color ||
          "rook" !== s.role ||
          (e.pieces.delete(t),
          e.pieces.delete(n),
          r[0] < i[0]
            ? (e.pieces.set(Xt([6, i[1]]), o), e.pieces.set(Xt([5, i[1]]), s))
            : (e.pieces.set(Xt([2, i[1]]), o), e.pieces.set(Xt([3, i[1]]), s)),
          0)
        );
      })(e, t, n) || (e.pieces.set(n, o), e.pieces.delete(t)),
      (e.lastMove = [t, n]),
      (e.check = void 0),
      ho(e.events.change),
      i || !0
    );
  }
  function vo(e, t, n, o) {
    if (e.pieces.has(n)) {
      if (!o) return !1;
      e.pieces.delete(n);
    }
    return (
      ho(e.events.dropNewPiece, t, n),
      e.pieces.set(n, t),
      (e.lastMove = [n]),
      (e.check = void 0),
      ho(e.events.change),
      (e.movable.dests = void 0),
      (e.turnColor = Zt(e.turnColor)),
      !0
    );
  }
  function go(e, t, n) {
    const o = mo(e, t, n);
    return (
      o &&
        ((e.movable.dests = void 0),
        (e.turnColor = Zt(e.turnColor)),
        (e.animation.current = void 0)),
      o
    );
  }
  function bo(e, t, n) {
    if (Co(e, t, n)) {
      const o = go(e, t, n);
      if (o) {
        const r = e.hold.stop();
        zo(e);
        const i = { premove: !1, ctrlKey: e.stats.ctrlKey, holdTime: r };
        return (
          !0 !== o && (i.captured = o), ho(e.movable.events.after, t, n, i), !0
        );
      }
    } else if (
      (function (e, t, n) {
        return (
          t !== n &&
          xo(e, t) &&
          uo(e.pieces, t, e.premovable.castle).includes(n)
        );
      })(e, t, n)
    )
      return (
        (function (e, t, n, o) {
          fo(e),
            (e.premovable.current = [t, n]),
            ho(e.premovable.events.set, t, n, o);
        })(e, t, n, { ctrlKey: e.stats.ctrlKey }),
        zo(e),
        !0
      );
    return zo(e), !1;
  }
  function ko(e, t, n, o) {
    const r = e.pieces.get(t);
    r &&
    ((function (e, t, n) {
      const o = e.pieces.get(t);
      return !(
        !o ||
        (t !== n && e.pieces.has(n)) ||
        ("both" !== e.movable.color &&
          (e.movable.color !== o.color || e.turnColor !== o.color))
      );
    })(e, t, n) ||
      o)
      ? (e.pieces.delete(t),
        vo(e, r, n, o),
        ho(e.movable.events.afterNewPiece, r.role, n, {
          premove: !1,
          predrop: !1,
        }))
      : r &&
        (function (e, t, n) {
          const o = e.pieces.get(t),
            r = e.pieces.get(n);
          return (
            !!o &&
            (!r || r.color !== e.movable.color) &&
            e.predroppable.enabled &&
            ("pawn" !== o.role || ("1" !== n[1] && "8" !== n[1])) &&
            e.movable.color === o.color &&
            e.turnColor !== o.color
          );
        })(e, t, n)
      ? (function (e, t, n) {
          po(e),
            (e.predroppable.current = { role: t, key: n }),
            ho(e.predroppable.events.set, t, n);
        })(e, r.role, n)
      : (po(e), fo(e)),
      e.pieces.delete(t),
      zo(e);
  }
  function wo(e, t, n) {
    if ((ho(e.events.select, t), e.selected)) {
      if (e.selected === t && !e.draggable.enabled)
        return zo(e), void e.hold.cancel();
      if (
        (e.selectable.enabled || n) &&
        e.selected !== t &&
        bo(e, e.selected, t)
      )
        return void (e.stats.dragged = !1);
    }
    (So(e, t) || xo(e, t)) && (yo(e, t), e.hold.start());
  }
  function yo(e, t) {
    (e.selected = t),
      xo(e, t)
        ? (e.premovable.dests = uo(e.pieces, t, e.premovable.castle))
        : (e.premovable.dests = void 0);
  }
  function zo(e) {
    (e.selected = void 0), (e.premovable.dests = void 0), e.hold.cancel();
  }
  function So(e, t) {
    const n = e.pieces.get(t);
    return (
      !!n &&
      ("both" === e.movable.color ||
        (e.movable.color === n.color && e.turnColor === n.color))
    );
  }
  function Co(e, t, n) {
    var o, r;
    return (
      t !== n &&
      So(e, t) &&
      (e.movable.free ||
        !!(null ===
          (r =
            null === (o = e.movable.dests) || void 0 === o
              ? void 0
              : o.get(t)) || void 0 === r
          ? void 0
          : r.includes(n)))
    );
  }
  function xo(e, t) {
    const n = e.pieces.get(t);
    return (
      !!n &&
      e.premovable.enabled &&
      e.movable.color === n.color &&
      e.turnColor !== n.color
    );
  }
  function Eo(e) {
    const t = e.premovable.current;
    if (!t) return !1;
    const n = t[0],
      o = t[1];
    let r = !1;
    if (Co(e, n, o)) {
      const t = go(e, n, o);
      if (t) {
        const i = { premove: !0 };
        !0 !== t && (i.captured = t),
          ho(e.movable.events.after, n, o, i),
          (r = !0);
      }
    }
    return po(e), r;
  }
  function Mo(e) {
    po(e), fo(e), zo(e);
  }
  function _o(e) {
    (e.movable.color = e.movable.dests = e.animation.current = void 0), Mo(e);
  }
  function Po(e, t, n) {
    let o = Math.floor((8 * (e[0] - n.left)) / n.width);
    t || (o = 7 - o);
    let r = 7 - Math.floor((8 * (e[1] - n.top)) / n.height);
    return (
      t || (r = 7 - r), o >= 0 && o < 8 && r >= 0 && r < 8 ? Xt([o, r]) : void 0
    );
  }
  function qo(e) {
    return "white" === e.orientation;
  }
  const Ao = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR",
    Oo = {
      p: "pawn",
      r: "rook",
      n: "knight",
      b: "bishop",
      q: "queen",
      k: "king",
    },
    Ro = {
      pawn: "p",
      rook: "r",
      knight: "n",
      bishop: "b",
      queen: "q",
      king: "k",
    };
  function No(e) {
    "start" === e && (e = Ao);
    const t = new Map();
    let n = 7,
      o = 0;
    for (const r of e)
      switch (r) {
        case " ":
        case "[":
          return t;
        case "/":
          if ((--n, n < 0)) return t;
          o = 0;
          break;
        case "~": {
          const e = t.get(Xt([o - 1, n]));
          e && (e.promoted = !0);
          break;
        }
        default: {
          const e = r.charCodeAt(0);
          if (e < 57) o += e - 48;
          else {
            const e = r.toLowerCase();
            t.set(Xt([o, n]), {
              role: Oo[e],
              color: r === e ? "black" : "white",
            }),
              ++o;
          }
        }
      }
    return t;
  }
  function Do(e, t) {
    t.animation &&
      ($o(e.animation, t.animation),
      (e.animation.duration || 0) < 70 && (e.animation.enabled = !1));
  }
  function To(e, t) {
    var n, o;
    if (
      ((null === (n = t.movable) || void 0 === n ? void 0 : n.dests) &&
        (e.movable.dests = void 0),
      (null === (o = t.drawable) || void 0 === o ? void 0 : o.autoShapes) &&
        (e.drawable.autoShapes = []),
      $o(e, t),
      t.fen && ((e.pieces = No(t.fen)), (e.drawable.shapes = [])),
      "check" in t &&
        (function (e, t) {
          if (((e.check = void 0), !0 === t && (t = e.turnColor), t))
            for (const [n, o] of e.pieces)
              "king" === o.role && o.color === t && (e.check = n);
        })(e, t.check || !1),
      "lastMove" in t && !t.lastMove
        ? (e.lastMove = void 0)
        : t.lastMove && (e.lastMove = t.lastMove),
      e.selected && yo(e, e.selected),
      Do(e, t),
      !e.movable.rookCastle && e.movable.dests)
    ) {
      const t = "white" === e.movable.color ? "1" : "8",
        n = "e" + t,
        o = e.movable.dests.get(n),
        r = e.pieces.get(n);
      if (!o || !r || "king" !== r.role) return;
      e.movable.dests.set(
        n,
        o.filter(
          (e) =>
            !(
              (e === "a" + t && o.includes("c" + t)) ||
              (e === "h" + t && o.includes("g" + t))
            )
        )
      );
    }
  }
  function $o(e, t) {
    for (const n in t) Io(e[n]) && Io(t[n]) ? $o(e[n], t[n]) : (e[n] = t[n]);
  }
  function Io(e) {
    return "object" == typeof e;
  }
  function Lo(e, t) {
    return t.animation.enabled
      ? (function (e, t) {
          const n = new Map(t.pieces),
            o = e(t),
            r = (function (e, t) {
              const n = new Map(),
                o = [],
                r = new Map(),
                i = [],
                s = [],
                a = new Map();
              let c, l, u;
              for (const [d, h] of e) a.set(d, Ko(d, h));
              for (const d of Gt)
                (c = t.pieces.get(d)),
                  (l = a.get(d)),
                  c
                    ? l
                      ? tn(c, l.piece) || (i.push(l), s.push(Ko(d, c)))
                      : s.push(Ko(d, c))
                    : l && i.push(l);
              for (const d of s)
                (l = Fo(
                  d,
                  i.filter((e) => tn(d.piece, e.piece))
                )),
                  l &&
                    ((u = [l.pos[0] - d.pos[0], l.pos[1] - d.pos[1]]),
                    n.set(d.key, u.concat(u)),
                    o.push(l.key));
              for (const d of i) o.includes(d.key) || r.set(d.key, d.piece);
              return { anims: n, fadings: r };
            })(n, t);
          if (r.anims.size || r.fadings.size) {
            const e = t.animation.current && t.animation.current.start;
            (t.animation.current = {
              start: performance.now(),
              frequency: 1 / t.animation.duration,
              plan: r,
            }),
              e || Vo(t, performance.now());
          } else t.dom.redraw();
          return o;
        })(e, t)
      : Bo(e, t);
  }
  function Bo(e, t) {
    const n = e(t);
    return t.dom.redraw(), n;
  }
  function Ko(e, t) {
    return { key: e, pos: Qt(e), piece: t };
  }
  function Fo(e, t) {
    return t.sort((t, n) => en(e.pos, t.pos) - en(e.pos, n.pos))[0];
  }
  function Vo(e, t) {
    const n = e.animation.current;
    if (void 0 === n) return void (e.dom.destroyed || e.dom.redrawNow());
    const o = 1 - (t - n.start) * n.frequency;
    if (o <= 0) (e.animation.current = void 0), e.dom.redrawNow();
    else {
      const t = (function (e) {
        return e < 0.5
          ? 4 * e * e * e
          : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
      })(o);
      for (const e of n.plan.anims.values())
        (e[2] = e[0] * t), (e[3] = e[1] * t);
      e.dom.redrawNow(!0),
        requestAnimationFrame((t = performance.now()) => Vo(e, t));
    }
  }
  const Wo = ["green", "red", "blue", "yellow"];
  function jo(e, t) {
    if (t.touches && t.touches.length > 1) return;
    t.stopPropagation(), t.preventDefault(), t.ctrlKey ? zo(e) : Mo(e);
    const n = an(t),
      o = Po(n, qo(e), e.dom.bounds());
    o &&
      ((e.drawable.current = {
        orig: o,
        pos: n,
        brush: Qo(t),
        snapToValidMove: e.drawable.defaultSnapToValidMove,
      }),
      Uo(e));
  }
  function Uo(e) {
    requestAnimationFrame(() => {
      const t = e.drawable.current;
      if (t) {
        const n = Po(t.pos, qo(e), e.dom.bounds());
        n || (t.snapToValidMove = !1);
        const o = t.snapToValidMove
          ? (function (e, t, n, o) {
              const r = Qt(e),
                i = Yt.filter(
                  (e) =>
                    lo(r[0], r[1], e[0], e[1]) || so(r[0], r[1], e[0], e[1])
                ),
                s = i.map((e) => un(Xt(e), n, o)).map((e) => en(t, e)),
                [, a] = s.reduce(
                  (e, t, n) => (e[0] < t ? e : [t, n]),
                  [s[0], 0]
                );
              return Xt(i[a]);
            })(t.orig, t.pos, qo(e), e.dom.bounds())
          : n;
        o !== t.mouseSq &&
          ((t.mouseSq = o),
          (t.dest = o !== t.orig ? o : void 0),
          e.dom.redrawNow()),
          Uo(e);
      }
    });
  }
  function Ho(e, t) {
    e.drawable.current && (e.drawable.current.pos = an(t));
  }
  function Go(e) {
    const t = e.drawable.current;
    t &&
      (t.mouseSq &&
        (function (e, t) {
          const n = (e) => e.orig === t.orig && e.dest === t.dest,
            o = e.shapes.find(n);
          o && (e.shapes = e.shapes.filter((e) => !n(e)));
          (o && o.brush === t.brush) || e.shapes.push(t);
          Yo(e);
        })(e.drawable, t),
      Xo(e));
  }
  function Xo(e) {
    e.drawable.current && ((e.drawable.current = void 0), e.dom.redraw());
  }
  function Qo(e) {
    var t;
    const n = (e.shiftKey || e.ctrlKey) && cn(e),
      o =
        e.altKey ||
        e.metaKey ||
        (null === (t = e.getModifierState) || void 0 === t
          ? void 0
          : t.call(e, "AltGraph"));
    return Wo[(n ? 1 : 0) + (o ? 2 : 0)];
  }
  function Yo(e) {
    e.onChange && e.onChange(e.shapes);
  }
  function Jo(e, t) {
    if (!t.isTrusted || (void 0 !== t.button && 0 !== t.button)) return;
    if (t.touches && t.touches.length > 1) return;
    const n = e.dom.bounds(),
      o = an(t),
      r = Po(o, qo(e), n);
    if (!r) return;
    const i = e.pieces.get(r),
      s = e.selected;
    var a;
    s ||
      !e.drawable.enabled ||
      (!e.drawable.eraseOnClick && i && i.color === e.turnColor) ||
      ((a = e).drawable.shapes.length &&
        ((a.drawable.shapes = []), a.dom.redraw(), Yo(a.drawable))),
      !1 !== t.cancelable &&
        (!t.touches ||
          e.blockTouchScroll ||
          i ||
          s ||
          (function (e, t) {
            const n = qo(e),
              o = e.dom.bounds(),
              r = Math.pow(o.width / 8, 2);
            for (const i of e.pieces.keys()) {
              const e = un(i, n, o);
              if (en(e, t) <= r) return !0;
            }
            return !1;
          })(e, o)) &&
        t.preventDefault();
    const c = !!e.premovable.current,
      l = !!e.predroppable.current;
    (e.stats.ctrlKey = t.ctrlKey),
      e.selected && Co(e, e.selected, r) ? Lo((e) => wo(e, r), e) : wo(e, r);
    const u = e.selected === r,
      d = rr(e, r);
    if (
      i &&
      d &&
      u &&
      (function (e, t) {
        const n = e.pieces.get(t);
        return (
          !!n &&
          e.draggable.enabled &&
          ("both" === e.movable.color ||
            (e.movable.color === n.color &&
              (e.turnColor === n.color || e.premovable.enabled)))
        );
      })(e, r)
    ) {
      (e.draggable.current = {
        orig: r,
        piece: i,
        origPos: o,
        pos: o,
        started: e.draggable.autoDistance && e.stats.dragged,
        element: d,
        previouslySelected: s,
        originTarget: t.target,
        keyHasChanged: !1,
      }),
        (d.cgDragging = !0),
        d.classList.add("dragging");
      const a = e.dom.elements.ghost;
      a &&
        ((a.className = `ghost ${i.color} ${i.role}`),
        on(a, nn(n)(Qt(r), qo(e))),
        sn(a, !0)),
        Zo(e);
    } else c && po(e), l && fo(e);
    e.dom.redraw();
  }
  function Zo(e) {
    requestAnimationFrame(() => {
      var t;
      const n = e.draggable.current;
      if (!n) return;
      (null === (t = e.animation.current) || void 0 === t
        ? void 0
        : t.plan.anims.has(n.orig)) && (e.animation.current = void 0);
      const o = e.pieces.get(n.orig);
      if (o && tn(o, n.piece)) {
        if (
          (!n.started &&
            en(n.pos, n.origPos) >= Math.pow(e.draggable.distance, 2) &&
            (n.started = !0),
          n.started)
        ) {
          if ("function" == typeof n.element) {
            const e = n.element();
            if (!e) return;
            (e.cgDragging = !0), e.classList.add("dragging"), (n.element = e);
          }
          const t = e.dom.bounds();
          on(n.element, [
            n.pos[0] - t.left - t.width / 16,
            n.pos[1] - t.top - t.height / 16,
          ]),
            n.keyHasChanged ||
              (n.keyHasChanged = n.orig !== Po(n.pos, qo(e), t));
        }
      } else nr(e);
      Zo(e);
    });
  }
  function er(e, t) {
    e.draggable.current &&
      (!t.touches || t.touches.length < 2) &&
      (e.draggable.current.pos = an(t));
  }
  function tr(e, t) {
    const n = e.draggable.current;
    if (!n) return;
    if (
      ("touchend" === t.type && !1 !== t.cancelable && t.preventDefault(),
      "touchend" === t.type && n.originTarget !== t.target && !n.newPiece)
    )
      return void (e.draggable.current = void 0);
    po(e), fo(e);
    const o = Po(an(t) || n.pos, qo(e), e.dom.bounds());
    o && n.started && n.orig !== o
      ? n.newPiece
        ? ko(e, n.orig, o, n.force)
        : ((e.stats.ctrlKey = t.ctrlKey),
          bo(e, n.orig, o) && (e.stats.dragged = !0))
      : n.newPiece
      ? e.pieces.delete(n.orig)
      : e.draggable.deleteOnDropOff &&
        !o &&
        (e.pieces.delete(n.orig), ho(e.events.change)),
      (((n.orig !== n.previouslySelected && !n.keyHasChanged) ||
        (n.orig !== o && o)) &&
        e.selectable.enabled) ||
        zo(e),
      or(e),
      (e.draggable.current = void 0),
      e.dom.redraw();
  }
  function nr(e) {
    const t = e.draggable.current;
    t &&
      (t.newPiece && e.pieces.delete(t.orig),
      (e.draggable.current = void 0),
      zo(e),
      or(e),
      e.dom.redraw());
  }
  function or(e) {
    const t = e.dom.elements;
    t.ghost && sn(t.ghost, !1);
  }
  function rr(e, t) {
    let n = e.dom.elements.board.firstChild;
    for (; n; ) {
      if (n.cgKey === t && "PIECE" === n.tagName) return n;
      n = n.nextSibling;
    }
  }
  function ir(e, t) {
    e.exploding &&
      (t ? (e.exploding.stage = t) : (e.exploding = void 0), e.dom.redraw());
  }
  function sr(e, t) {
    function n() {
      !(function (e) {
        (e.orientation = Zt(e.orientation)),
          (e.animation.current = e.draggable.current = e.selected = void 0);
      })(e),
        t();
    }
    return {
      set(t) {
        t.orientation && t.orientation !== e.orientation && n(),
          Do(e, t),
          (t.fen ? Lo : Bo)((e) => To(e, t), e);
      },
      state: e,
      getFen: () => {
        return (
          (t = e.pieces),
          Ht.map((e) =>
            jt
              .map((n) => {
                const o = t.get(n + e);
                if (o) {
                  let e = Ro[o.role];
                  return (
                    "white" === o.color && (e = e.toUpperCase()),
                    o.promoted && (e += "~"),
                    e
                  );
                }
                return "1";
              })
              .join("")
          )
            .join("/")
            .replace(/1{2,}/g, (e) => e.length.toString())
        );
        var t;
      },
      toggleOrientation: n,
      setPieces(t) {
        Lo(
          (e) =>
            (function (e, t) {
              for (const [n, o] of t)
                o ? e.pieces.set(n, o) : e.pieces.delete(n);
            })(e, t),
          e
        );
      },
      selectSquare(t, n) {
        t ? Lo((e) => wo(e, t, n), e) : e.selected && (zo(e), e.dom.redraw());
      },
      move(t, n) {
        Lo((e) => mo(e, t, n), e);
      },
      newPiece(t, n) {
        Lo((e) => vo(e, t, n), e);
      },
      playPremove() {
        if (e.premovable.current) {
          if (Lo(Eo, e)) return !0;
          e.dom.redraw();
        }
        return !1;
      },
      playPredrop(t) {
        if (e.predroppable.current) {
          const n = (function (e, t) {
            const n = e.predroppable.current;
            let o = !1;
            if (!n) return !1;
            t(n) &&
              vo(e, { role: n.role, color: e.movable.color }, n.key) &&
              (ho(e.movable.events.afterNewPiece, n.role, n.key, {
                premove: !1,
                predrop: !0,
              }),
              (o = !0));
            return fo(e), o;
          })(e, t);
          return e.dom.redraw(), n;
        }
        return !1;
      },
      cancelPremove() {
        Bo(po, e);
      },
      cancelPredrop() {
        Bo(fo, e);
      },
      cancelMove() {
        Bo((e) => {
          Mo(e), nr(e);
        }, e);
      },
      stop() {
        Bo((e) => {
          _o(e), nr(e);
        }, e);
      },
      explode(t) {
        !(function (e, t) {
          (e.exploding = { stage: 1, keys: t }),
            e.dom.redraw(),
            setTimeout(() => {
              ir(e, 2), setTimeout(() => ir(e, void 0), 120);
            }, 120);
        })(e, t);
      },
      setAutoShapes(t) {
        Bo((e) => (e.drawable.autoShapes = t), e);
      },
      setShapes(t) {
        Bo((e) => (e.drawable.shapes = t), e);
      },
      getKeyAtDomPos: (t) => Po(t, qo(e), e.dom.bounds()),
      redrawAll: t,
      dragNewPiece(t, n, o) {
        !(function (e, t, n, o) {
          const r = "a0";
          e.pieces.set(r, t), e.dom.redraw();
          const i = an(n);
          (e.draggable.current = {
            orig: r,
            piece: t,
            origPos: i,
            pos: i,
            started: !0,
            element: () => rr(e, r),
            originTarget: n.target,
            newPiece: !0,
            force: !!o,
            keyHasChanged: !1,
          }),
            Zo(e);
        })(e, t, n, o);
      },
      destroy() {
        _o(e), e.dom.unbind && e.dom.unbind(), (e.dom.destroyed = !0);
      },
    };
  }
  function ar(e, t, n) {
    const o = new Map(),
      r = [];
    for (const a of e) o.set(a.hash, !1);
    let i,
      s = t.firstChild;
    for (; s; )
      (i = s.getAttribute("cgHash")),
        o.has(i) ? o.set(i, !0) : r.push(s),
        (s = s.nextSibling);
    for (const a of r) t.removeChild(a);
    for (const a of e) o.get(a.hash) || t.appendChild(n(a));
  }
  function cr(e) {
    return document.createElementNS("http://www.w3.org/2000/svg", e);
  }
  function lr(e, t, n) {
    const o = e.drawable,
      r = o.current,
      i = r && r.mouseSq ? r : void 0,
      s = new Map(),
      a = e.dom.bounds(),
      c = o.autoShapes.filter((e) => !e.piece);
    for (const f of o.shapes.concat(c).concat(i ? [i] : []))
      f.dest && s.set(f.dest, (s.get(f.dest) || 0) + 1);
    const l = o.shapes
      .concat(c)
      .map((e) => ({ shape: e, current: !1, hash: ur(e, s, !1, a) }));
    i && l.push({ shape: i, current: !0, hash: ur(i, s, !0, a) });
    const u = l.map((e) => e.hash).join(";");
    if (u === e.drawable.prevSvgHash) return;
    e.drawable.prevSvgHash = u;
    const d = t.querySelector("defs"),
      h = t.querySelector("g"),
      p = n.querySelector("g");
    !(function (e, t, n) {
      const o = new Map();
      let r;
      for (const a of t)
        a.shape.dest &&
          ((r = e.brushes[a.shape.brush]),
          a.shape.modifiers && (r = gr(r, a.shape.modifiers)),
          o.set(r.key, r));
      const i = new Set();
      let s = n.firstChild;
      for (; s; ) i.add(s.getAttribute("cgKey")), (s = s.nextSibling);
      for (const [a, c] of o.entries()) i.has(a) || n.appendChild(fr(c));
    })(o, l, d),
      ar(
        l.filter((e) => !e.shape.customSvg),
        h,
        (t) => pr(e, t, o.brushes, s, a)
      ),
      ar(
        l.filter((e) => e.shape.customSvg),
        p,
        (t) => pr(e, t, o.brushes, s, a)
      );
  }
  function ur(
    { orig: e, dest: t, brush: n, piece: o, modifiers: r, customSvg: i },
    s,
    a,
    c
  ) {
    return [
      c.width,
      c.height,
      a,
      e,
      t,
      n,
      t && (s.get(t) || 0) > 1,
      o && dr(o),
      r && ((l = r), "" + (l.lineWidth || "")),
      i && hr(i),
    ]
      .filter((e) => e)
      .join(",");
    var l;
  }
  function dr(e) {
    return [e.color, e.role, e.scale].filter((e) => e).join(",");
  }
  function hr(e) {
    let t = 0;
    for (let n = 0; n < e.length; n++)
      t = ((t << 5) - t + e.charCodeAt(n)) >>> 0;
    return "custom-" + t.toString();
  }
  function pr(e, { shape: t, current: n, hash: o }, r, i, s) {
    let a;
    const c = vr(Qt(t.orig), e.orientation);
    if (t.customSvg)
      a = (function (e, t, n) {
        const [o, r] = wr(t, n),
          i = mr(cr("g"), { transform: `translate(${o},${r})` }),
          s = mr(cr("svg"), { width: 1, height: 1, viewBox: "0 0 100 100" });
        return i.appendChild(s), (s.innerHTML = e), i;
      })(t.customSvg, c, s);
    else if (t.dest) {
      let o = r[t.brush];
      t.modifiers && (o = gr(o, t.modifiers)),
        (a = (function (e, t, n, o, r, i) {
          const s = (function (e) {
              return (e ? 20 : 10) / 64;
            })(r && !o),
            a = wr(t, i),
            c = wr(n, i),
            l = c[0] - a[0],
            u = c[1] - a[1],
            d = Math.atan2(u, l),
            h = Math.cos(d) * s,
            p = Math.sin(d) * s;
          return mr(cr("line"), {
            stroke: e.color,
            "stroke-width": br(e, o),
            "stroke-linecap": "round",
            "marker-end": "url(#arrowhead-" + e.key + ")",
            opacity: kr(e, o),
            x1: a[0],
            y1: a[1],
            x2: c[0] - h,
            y2: c[1] - p,
          });
        })(
          o,
          c,
          vr(Qt(t.dest), e.orientation),
          n,
          (i.get(t.dest) || 0) > 1,
          s
        ));
    } else
      a = (function (e, t, n, o) {
        const r = wr(t, o),
          i = [3 / 64, 4 / 64],
          s = (o.width + o.height) / (4 * Math.max(o.width, o.height));
        return mr(cr("circle"), {
          stroke: e.color,
          "stroke-width": i[n ? 0 : 1],
          fill: "none",
          opacity: kr(e, n),
          cx: r[0],
          cy: r[1],
          r: s - i[1] / 2,
        });
      })(r[t.brush], c, n, s);
    return a.setAttribute("cgHash", o), a;
  }
  function fr(e) {
    const t = mr(cr("marker"), {
      id: "arrowhead-" + e.key,
      orient: "auto",
      markerWidth: 4,
      markerHeight: 8,
      refX: 2.05,
      refY: 2.01,
    });
    return (
      t.appendChild(mr(cr("path"), { d: "M0,0 V4 L3,2 Z", fill: e.color })),
      t.setAttribute("cgKey", e.key),
      t
    );
  }
  function mr(e, t) {
    for (const n in t) e.setAttribute(n, t[n]);
    return e;
  }
  function vr(e, t) {
    return "white" === t ? e : [7 - e[0], 7 - e[1]];
  }
  function gr(e, t) {
    return {
      color: e.color,
      opacity: Math.round(10 * e.opacity) / 10,
      lineWidth: Math.round(t.lineWidth || e.lineWidth),
      key: [e.key, t.lineWidth].filter((e) => e).join(""),
    };
  }
  function br(e, t) {
    return ((e.lineWidth || 10) * (t ? 0.85 : 1)) / 64;
  }
  function kr(e, t) {
    return (e.opacity || 1) * (t ? 0.9 : 1);
  }
  function wr(e, t) {
    const n = Math.min(1, t.width / t.height),
      o = Math.min(1, t.height / t.width);
    return [(e[0] - 3.5) * n, (3.5 - e[1]) * o];
  }
  function yr(e, t) {
    const n = ln("coords", t);
    let o;
    for (const r of e) (o = ln("coord")), (o.textContent = r), n.appendChild(o);
    return n;
  }
  function zr(e, t) {
    const n = e.dom.elements.board;
    if (
      ("ResizeObserver" in window &&
        new ResizeObserver(t).observe(e.dom.elements.wrap),
      e.viewOnly)
    )
      return;
    const o = (function (e) {
      return (t) => {
        e.draggable.current
          ? nr(e)
          : e.drawable.current
          ? Xo(e)
          : t.shiftKey || cn(t)
          ? e.drawable.enabled && jo(e, t)
          : e.viewOnly ||
            (e.dropmode.active
              ? (function (e, t) {
                  if (!e.dropmode.active) return;
                  po(e), fo(e);
                  const n = e.dropmode.piece;
                  if (n) {
                    e.pieces.set("a0", n);
                    const o = an(t),
                      r = o && Po(o, qo(e), e.dom.bounds());
                    r && ko(e, "a0", r);
                  }
                  e.dom.redraw();
                })(e, t)
              : Jo(e, t));
      };
    })(e);
    n.addEventListener("touchstart", o, { passive: !1 }),
      n.addEventListener("mousedown", o, { passive: !1 }),
      (e.disableContextMenu || e.drawable.enabled) &&
        n.addEventListener("contextmenu", (e) => e.preventDefault());
  }
  function Sr(e, t, n, o) {
    return e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o);
  }
  function Cr(e, t, n) {
    return (o) => {
      e.drawable.current
        ? e.drawable.enabled && n(e, o)
        : e.viewOnly || t(e, o);
    };
  }
  function xr(e) {
    const t = qo(e),
      n = nn(e.dom.bounds()),
      o = e.dom.elements.board,
      r = e.pieces,
      i = e.animation.current,
      s = i ? i.plan.anims : new Map(),
      a = i ? i.plan.fadings : new Map(),
      c = e.draggable.current,
      l = (function (e) {
        var t;
        const n = new Map();
        if (e.lastMove && e.highlight.lastMove)
          for (const i of e.lastMove) Or(n, i, "last-move");
        e.check && e.highlight.check && Or(n, e.check, "check");
        if (
          e.selected &&
          (Or(n, e.selected, "selected"), e.movable.showDests)
        ) {
          const o =
            null === (t = e.movable.dests) || void 0 === t
              ? void 0
              : t.get(e.selected);
          if (o)
            for (const t of o)
              Or(n, t, "move-dest" + (e.pieces.has(t) ? " oc" : ""));
          const r = e.premovable.dests;
          if (r)
            for (const t of r)
              Or(n, t, "premove-dest" + (e.pieces.has(t) ? " oc" : ""));
        }
        const o = e.premovable.current;
        if (o) for (const i of o) Or(n, i, "current-premove");
        else
          e.predroppable.current &&
            Or(n, e.predroppable.current.key, "current-premove");
        const r = e.exploding;
        if (r) for (const i of r.keys) Or(n, i, "exploding" + r.stage);
        return n;
      })(e),
      u = new Set(),
      d = new Set(),
      h = new Map(),
      p = new Map();
    let f, m, v, g, b, k, w, y, z, S;
    for (m = o.firstChild; m; ) {
      if (((f = m.cgKey), Mr(m)))
        if (
          ((v = r.get(f)),
          (b = s.get(f)),
          (k = a.get(f)),
          (g = m.cgPiece),
          !m.cgDragging ||
            (c && c.orig === f) ||
            (m.classList.remove("dragging"),
            on(m, n(Qt(f), t)),
            (m.cgDragging = !1)),
          !k && m.cgFading && ((m.cgFading = !1), m.classList.remove("fading")),
          v)
        ) {
          if (b && m.cgAnimating && g === Ar(v)) {
            const e = Qt(f);
            (e[0] += b[2]),
              (e[1] += b[3]),
              m.classList.add("anim"),
              on(m, n(e, t));
          } else
            m.cgAnimating &&
              ((m.cgAnimating = !1),
              m.classList.remove("anim"),
              on(m, n(Qt(f), t)),
              e.addPieceZIndex && (m.style.zIndex = qr(Qt(f), t)));
          g !== Ar(v) || (k && m.cgFading)
            ? k && g === Ar(k)
              ? (m.classList.add("fading"), (m.cgFading = !0))
              : Rr(h, g, m)
            : u.add(f);
        } else Rr(h, g, m);
      else if (_r(m)) {
        const e = m.className;
        l.get(f) === e ? d.add(f) : Rr(p, e, m);
      }
      m = m.nextSibling;
    }
    for (const [C, x] of l)
      if (!d.has(C)) {
        (z = p.get(x)), (S = z && z.pop());
        const e = n(Qt(C), t);
        if (S) (S.cgKey = C), on(S, e);
        else {
          const t = ln("square", x);
          (t.cgKey = C), on(t, e), o.insertBefore(t, o.firstChild);
        }
      }
    for (const [C, x] of r)
      if (((b = s.get(C)), !u.has(C)))
        if (((w = h.get(Ar(x))), (y = w && w.pop()), y)) {
          (y.cgKey = C),
            y.cgFading && (y.classList.remove("fading"), (y.cgFading = !1));
          const o = Qt(C);
          e.addPieceZIndex && (y.style.zIndex = qr(o, t)),
            b &&
              ((y.cgAnimating = !0),
              y.classList.add("anim"),
              (o[0] += b[2]),
              (o[1] += b[3])),
            on(y, n(o, t));
        } else {
          const r = Ar(x),
            i = ln("piece", r),
            s = Qt(C);
          (i.cgPiece = r),
            (i.cgKey = C),
            b && ((i.cgAnimating = !0), (s[0] += b[2]), (s[1] += b[3])),
            on(i, n(s, t)),
            e.addPieceZIndex && (i.style.zIndex = qr(s, t)),
            o.appendChild(i);
        }
    for (const C of h.values()) Pr(e, C);
    for (const C of p.values()) Pr(e, C);
  }
  function Er(e) {
    const t = e.dom.elements.wrap.getBoundingClientRect(),
      n = e.dom.elements.container,
      o = t.height / t.width,
      r =
        (8 * Math.floor((t.width * window.devicePixelRatio) / 8)) /
        window.devicePixelRatio,
      i = r * o;
    (n.style.width = r + "px"),
      (n.style.height = i + "px"),
      e.dom.bounds.clear(),
      e.addDimensionsCssVars &&
        (document.documentElement.style.setProperty("--cg-width", r + "px"),
        document.documentElement.style.setProperty("--cg-height", i + "px"));
  }
  function Mr(e) {
    return "PIECE" === e.tagName;
  }
  function _r(e) {
    return "SQUARE" === e.tagName;
  }
  function Pr(e, t) {
    for (const n of t) e.dom.elements.board.removeChild(n);
  }
  function qr(e, t) {
    const n = e[1];
    return `${t ? 10 - n : 3 + n}`;
  }
  function Ar(e) {
    return `${e.color} ${e.role}`;
  }
  function Or(e, t, n) {
    const o = e.get(t);
    o ? e.set(t, `${o} ${n}`) : e.set(t, n);
  }
  function Rr(e, t, n) {
    const o = e.get(t);
    o ? o.push(n) : e.set(t, [n]);
  }
  function Nr(e, t) {
    ar(
      e.drawable.autoShapes
        .filter((e) => e.piece)
        .map((e) => {
          return {
            shape: e,
            hash:
              ((t = e),
              [
                t.orig,
                null === (n = t.piece) || void 0 === n ? void 0 : n.role,
                null === (o = t.piece) || void 0 === o ? void 0 : o.color,
                null === (r = t.piece) || void 0 === r ? void 0 : r.scale,
              ].join(",")),
            current: !1,
          };
          var t, n, o, r;
        }),
      t,
      (t) =>
        (function (e, { shape: t, hash: n }, o) {
          var r, i, s;
          const a = t.orig,
            c = null === (r = t.piece) || void 0 === r ? void 0 : r.role,
            l = null === (i = t.piece) || void 0 === i ? void 0 : i.color,
            u = null === (s = t.piece) || void 0 === s ? void 0 : s.scale,
            d = ln("piece", `${c} ${l}`);
          return (
            d.setAttribute("cgHash", n),
            (d.cgKey = a),
            (d.cgScale = u),
            rn(d, nn(o)(Qt(a), qo(e)), u),
            d
          );
        })(e, t, e.dom.bounds())
    );
  }
  function Dr(e, t) {
    const n = {
      pieces: No(Ao),
      orientation: "white",
      turnColor: "white",
      coordinates: !0,
      ranksPosition: "right",
      autoCastle: !0,
      viewOnly: !1,
      disableContextMenu: !1,
      addPieceZIndex: !1,
      addDimensionsCssVars: !1,
      blockTouchScroll: !1,
      pieceKey: !1,
      highlight: { lastMove: !0, check: !0 },
      animation: { enabled: !0, duration: 200 },
      movable: {
        free: !0,
        color: "both",
        showDests: !0,
        events: {},
        rookCastle: !0,
      },
      premovable: { enabled: !0, showDests: !0, castle: !0, events: {} },
      predroppable: { enabled: !1, events: {} },
      draggable: {
        enabled: !0,
        distance: 3,
        autoDistance: !0,
        showGhost: !0,
        deleteOnDropOff: !1,
      },
      dropmode: { active: !1 },
      selectable: { enabled: !0 },
      stats: { dragged: !("ontouchstart" in window) },
      events: {},
      drawable: {
        enabled: !0,
        visible: !0,
        defaultSnapToValidMove: !0,
        eraseOnClick: !0,
        shapes: [],
        autoShapes: [],
        brushes: {
          green: { key: "g", color: "#15781B", opacity: 1, lineWidth: 10 },
          red: { key: "r", color: "#882020", opacity: 1, lineWidth: 10 },
          blue: { key: "b", color: "#003088", opacity: 1, lineWidth: 10 },
          yellow: { key: "y", color: "#e68f00", opacity: 1, lineWidth: 10 },
          paleBlue: {
            key: "pb",
            color: "#003088",
            opacity: 0.4,
            lineWidth: 15,
          },
          paleGreen: {
            key: "pg",
            color: "#15781B",
            opacity: 0.4,
            lineWidth: 15,
          },
          paleRed: { key: "pr", color: "#882020", opacity: 0.4, lineWidth: 15 },
          paleGrey: {
            key: "pgr",
            color: "#4a4a4a",
            opacity: 0.35,
            lineWidth: 15,
          },
        },
        prevSvgHash: "",
      },
      hold: Jt(),
    };
    function o() {
      const t = "dom" in n ? n.dom.unbind : void 0,
        o = (function (e, t) {
          (e.innerHTML = ""), e.classList.add("cg-wrap");
          for (const c of Wt)
            e.classList.toggle("orientation-" + c, t.orientation === c);
          e.classList.toggle("manipulable", !t.viewOnly);
          const n = ln("cg-container");
          e.appendChild(n);
          const o = ln("cg-board");
          let r, i, s, a;
          if (
            (n.appendChild(o),
            t.drawable.visible &&
              ((r = mr(cr("svg"), {
                class: "cg-shapes",
                viewBox: "-4 -4 8 8",
                preserveAspectRatio: "xMidYMid slice",
              })),
              r.appendChild(cr("defs")),
              r.appendChild(cr("g")),
              (i = mr(cr("svg"), {
                class: "cg-custom-svgs",
                viewBox: "-3.5 -3.5 8 8",
                preserveAspectRatio: "xMidYMid slice",
              })),
              i.appendChild(cr("g")),
              (s = ln("cg-auto-pieces")),
              n.appendChild(r),
              n.appendChild(i),
              n.appendChild(s)),
            t.coordinates)
          ) {
            const e = "black" === t.orientation ? " black" : "",
              o = "left" === t.ranksPosition ? " left" : "";
            n.appendChild(yr(Ut, "ranks" + e + o)),
              n.appendChild(yr(jt, "files" + e));
          }
          return (
            t.draggable.showGhost &&
              ((a = ln("piece", "ghost")), sn(a, !1), n.appendChild(a)),
            {
              board: o,
              container: n,
              wrap: e,
              ghost: a,
              svg: r,
              customSvg: i,
              autoPieces: s,
            }
          );
        })(e, n),
        r = (function (e) {
          let t;
          const n = () => (void 0 === t && (t = e()), t);
          return (
            (n.clear = () => {
              t = void 0;
            }),
            n
          );
        })(() => o.board.getBoundingClientRect()),
        i = (e) => {
          xr(a),
            o.autoPieces && Nr(a, o.autoPieces),
            !e && o.svg && lr(a, o.svg, o.customSvg);
        },
        s = () => {
          Er(a),
            (function (e) {
              const t = qo(e),
                n = nn(e.dom.bounds());
              let o = e.dom.elements.board.firstChild;
              for (; o; )
                ((Mr(o) && !o.cgAnimating) || _r(o)) &&
                  on(o, n(Qt(o.cgKey), t)),
                  (o = o.nextSibling);
            })(a),
            o.autoPieces &&
              (function (e) {
                var t;
                const n = qo(e),
                  o = nn(e.dom.bounds());
                let r =
                  null === (t = e.dom.elements.autoPieces) || void 0 === t
                    ? void 0
                    : t.firstChild;
                for (; r; )
                  rn(r, o(Qt(r.cgKey), n), r.cgScale), (r = r.nextSibling);
              })(a);
        },
        a = n;
      return (
        (a.dom = {
          elements: o,
          bounds: r,
          redraw: Tr(i),
          redrawNow: i,
          unbind: t,
        }),
        (a.drawable.prevSvgHash = ""),
        Er(a),
        i(!1),
        zr(a, s),
        t ||
          (a.dom.unbind = (function (e, t) {
            const n = [];
            if (
              ("ResizeObserver" in window ||
                n.push(Sr(document.body, "chessground.resize", t)),
              !e.viewOnly)
            ) {
              const t = Cr(e, er, Ho),
                o = Cr(e, tr, Go);
              for (const e of ["touchmove", "mousemove"])
                n.push(Sr(document, e, t));
              for (const e of ["touchend", "mouseup"])
                n.push(Sr(document, e, o));
              const r = () => e.dom.bounds.clear();
              n.push(Sr(document, "scroll", r, { capture: !0, passive: !0 })),
                n.push(Sr(window, "resize", r, { passive: !0 }));
            }
            return () => n.forEach((e) => e());
          })(a, s)),
        a.events.insert && a.events.insert(o),
        a
      );
    }
    return To(n, t || {}), sr(o(), o);
  }
  function Tr(e) {
    let t = !1;
    return () => {
      t ||
        ((t = !0),
        requestAnimationFrame(() => {
          e(), (t = !1);
        }));
    };
  }
  function $r(e) {
    return d("div.cg-wrap", {
      hook: {
        insert: (t) =>
          e.ground(
            Dr(
              t.elm,
              (function (e) {
                const t = e.makeCgOpts();
                return {
                  fen: t.fen,
                  orientation: t.orientation,
                  turnColor: t.turnColor,
                  check: t.check,
                  lastMove: t.lastMove,
                  coordinates: 0 !== e.pref.coords,
                  addPieceZIndex: e.pref.is3d,
                  addDimensionsCssVars: !0,
                  movable: {
                    free: !1,
                    color: t.movable.color,
                    dests: t.movable.dests,
                    showDests: e.pref.destination,
                    rookCastle: e.pref.rookCastle,
                  },
                  draggable: {
                    enabled: e.pref.moveEvent > 0,
                    showGhost: e.pref.highlight,
                  },
                  selectable: { enabled: 1 !== e.pref.moveEvent },
                  events: {
                    move: e.userMove,
                    insert(t) {
                      oo(t, 2, e.vm.node.ply);
                    },
                  },
                  premovable: { enabled: t.premovable.enabled },
                  drawable: {
                    enabled: !0,
                    defaultSnapToValidMove:
                      "0" != (lichess.storage.get("arrow.snap") || 1),
                  },
                  highlight: {
                    lastMove: e.pref.highlight,
                    check: e.pref.highlight,
                  },
                  animation: {
                    enabled: !0,
                    duration: e.pref.animation.duration,
                  },
                  disableContextMenu: !0,
                };
              })(e)
            )
          ),
        destroy: (t) => e.ground().destroy(),
      },
    });
  }
  const Ir = (e) => {
      var t;
      return d(
        "div.puzzle__vote",
        e.autoNexting()
          ? []
          : [
              e.session.isNew() &&
              (null === (t = e.getData().user) || void 0 === t
                ? void 0
                : t.provisional)
                ? d("div.puzzle__vote__help", [
                    d("p", e.trans.noarg("didYouLikeThisPuzzle")),
                    d("p", e.trans.noarg("voteToLoadNextOne")),
                  ])
                : null,
              d(
                "div.puzzle__vote__buttons",
                { class: { enabled: !e.vm.voteDisabled } },
                [
                  d("div.vote.vote-up", {
                    hook: An("click", () => e.vote(!0)),
                  }),
                  d("div.vote.vote-down", {
                    hook: An("click", () => e.vote(!1)),
                  }),
                ]
              ),
            ]
      );
    },
    Lr = (e) =>
      d("a.continue", { hook: An("click", e.nextPuzzle) }, [
        d("i", { attrs: On("") }),
        e.trans.noarg("continueTraining"),
      ]);
  function Br(e) {
    const t = e.getData(),
      n = "win" == e.vm.lastFeedback;
    return d(
      "div.puzzle__feedback.after",
      e.streak && !n
        ? ((e) => {
            var t;
            return [
              d("div.complete", [
                d("span.game-over", "GAME OVER"),
                d(
                  "span",
                  e.trans.vdom(
                    "yourStreakX",
                    d(
                      "strong",
                      null === (t = e.streak) || void 0 === t
                        ? void 0
                        : t.data.index
                    )
                  )
                ),
              ]),
              // d("a.continue", { attrs: { href: "/streak" } }, [d("i", { attrs: On("") }), e.trans("newStreak")]), Alterador por mim
            ];
          })(e)
        : [
            d(
              "div.complete",
              e.trans.noarg(n ? "puzzleSuccess" : "puzzleComplete")
            ),
            // t.user ? Ir(e) : Lr(e), Alterado por mim
            d("div.puzzle__more", [
              d("a", {
                attrs: {
                  "data-icon": "",
                  href: `/analysis/${e.vm.node.fen.replace(/ /g, "_")}?color=${
                    e.vm.pov
                  }#practice`,
                  title: e.trans.noarg("playWithTheMachine"),
                  target: "_blank",
                  rel: "noopener",
                },
              }),
              t.user && !e.autoNexting()
                ? d(
                    "a",
                    { hook: An("click", e.nextPuzzle) },
                    e.trans.noarg(
                      e.streak ? "continueTheStreak" : "continueTraining"
                    )
                  )
                : void 0,
            ]),
          ]
    );
  }
  const Kr = (e) => {
    var t;
    return e.streak
      ? d(
          "div.view_solution.skip",
          {
            class: {
              show: !!(null === (t = e.streak) || void 0 === t
                ? void 0
                : t.data.skip),
            },
          },
          [
            d(
              "a.button.button-empty",
              {
                hook: An("click", e.skip),
                attrs: { title: e.trans.noarg("streakSkipExplanation") },
              },
              e.trans.noarg("skip")
            ),
          ]
        )
      : d("div.view_solution", { class: { show: e.vm.canViewSolution } }, [
          d(
            "a.button.button-empty",
            { hook: An("click", e.viewSolution) },
            e.trans.noarg("viewTheSolution")
          ),
        ]);
  };
  function Fr(e) {
    if ("view" === e.vm.mode) return Br(e);
    switch (e.vm.lastFeedback) {
      case "init":
        return ((e) =>
          d("div.puzzle__feedback.play", [
            d("div.player", [
              d("div.no-square", d("piece.king." + e.vm.pov)),
              d("div.instruction", [
                d("strong", e.trans.noarg("yourTurn")),
                d(
                  "em",
                  e.trans.noarg(
                    "white" === e.vm.pov
                      ? "findTheBestMoveForWhite"
                      : "findTheBestMoveForBlack"
                  )
                ),
              ]),
            ]),
            Kr(e),
          ]))(e);
      case "good":
        return ((e) =>
          d("div.puzzle__feedback.good", [
            d("div.player", [
              d("div.icon", "✓"),
              d("div.instruction", [
                d("strong", e.trans.noarg("bestMove")),
                d("em", e.trans.noarg("keepGoing")),
              ]),
            ]),
            Kr(e),
          ]))(e);
      case "fail":
        return ((e) =>
          d("div.puzzle__feedback.fail", [
            d("div.player", [
              d("div.icon", "✗"),
              d("div.instruction", [
                d("strong", e.trans.noarg("notTheMove")),
                d("em", e.trans.noarg("trySomethingElse")),
              ]),
            ]),
            Kr(e),
          ]))(e);
    }
  }
  const Vr = P(150, (e, t) => {
    const n = t.parentNode,
      o = t.querySelector(".active");
    n.scrollTop = o
      ? o.offsetTop - n.offsetHeight / 2 + o.offsetHeight
      : "" === e.vm.path
      ? 0
      : 99999;
  });
  function Wr(e, t) {
    return vn(e.ctrl.vm.path, t);
  }
  function jr(e, t) {
    return d(
      "index",
      (function (e) {
        return Math.floor((e - 1) / 2) + 1;
      })(e) + (t ? (e % 2 == 1 ? "." : "...") : "")
    );
  }
  function Ur(e, t, n) {
    const o = t.children,
      r = o[0];
    if (!r) return [];
    if (n.isMainline) {
      const t = r.ply % 2 == 1;
      if (!o[1])
        return [
          t ? jr(r.ply, !1) : null,
          ...Yr(e, r, { parentPath: n.parentPath, isMainline: !0 }),
        ];
      const i = Ur(e, r, { parentPath: n.parentPath + r.id, isMainline: !0 }),
        s = { parentPath: n.parentPath, isMainline: !0 };
      return [
        t ? jr(r.ply, !1) : null,
        Gr(e, r, s),
        t ? Jr() : null,
        d(
          "interrupt",
          Hr(e, o.slice(1), { parentPath: n.parentPath, isMainline: !0 })
        ),
        ...(t && i ? [jr(r.ply, !1), Jr()] : []),
        ...i,
      ];
    }
    return o[1] ? [Hr(e, o, n)] : Yr(e, r, n);
  }
  function Hr(e, t, n) {
    return d(
      "lines",
      { class: { single: !!t[1] } },
      t.map(function (t) {
        return d(
          "line",
          Yr(e, t, { parentPath: n.parentPath, isMainline: !1, withIndex: !0 })
        );
      })
    );
  }
  function Gr(e, t, n) {
    return n.isMainline
      ? (function (e, t, n) {
          const o = n.parentPath + t.id,
            r = {
              active: o === e.ctrl.vm.path,
              current: o === e.ctrl.vm.initialPath,
              hist: t.ply < e.ctrl.vm.initialNode.ply,
            };
          t.puzzle && (r[t.puzzle] = !0);
          return d(
            "move",
            { attrs: { p: o }, class: r },
            (function (e, t) {
              const n = t.eval || t.ceval;
              return [
                t.san,
                n &&
                  (b(n.cp)
                    ? Zr(he(n.cp))
                    : b(n.mate)
                    ? Zr("#" + n.mate)
                    : void 0),
                Qr(e, t),
              ];
            })(e, t)
          );
        })(e, t, n)
      : (function (e, t, n) {
          const o = n.withIndex || t.ply % 2 == 1,
            r = n.parentPath + t.id,
            i = r === e.ctrl.vm.path,
            s = { active: i, parent: !i && Wr(e, r) };
          t.puzzle && (s[t.puzzle] = !0);
          return d("move", { attrs: { p: r }, class: s }, [
            o ? jr(t.ply, !0) : null,
            t.san,
            Qr(e, t),
          ]);
        })(e, t, n);
  }
  function Xr(e) {
    return d("glyph", { attrs: { title: e.name } }, e.symbol);
  }
  function Qr(e, t) {
    switch (t.puzzle) {
      case "good":
      case "win":
        return Xr({ name: e.ctrl.trans.noarg("bestMove"), symbol: "✓" });
      case "fail":
        return Xr({ name: e.ctrl.trans.noarg("puzzleFailed"), symbol: "✗" });
      case "retry":
        return Xr({ name: e.ctrl.trans.noarg("goodMove"), symbol: "?!" });
      default:
        return;
    }
  }
  function Yr(e, t, n) {
    return [
      Gr(e, t, n),
      ...Ur(e, t, {
        parentPath: n.parentPath + t.id,
        isMainline: n.isMainline,
      }),
    ];
  }
  function Jr() {
    return d("move.empty", "...");
  }
  function Zr(e) {
    return d("eval", e);
  }
  function ei(e) {
    const t = e.getTree().root,
      n = { ctrl: e, showComputer: !1 };
    return d(
      "div.tview2.tview2-column",
      {
        hook: {
          insert: (t) => {
            const n = t.elm;
            "" !== e.path && Vr(e, n),
              n.addEventListener("mousedown", (t) => {
                if (b(t.button) && 0 !== t.button) return;
                const n = (function (e) {
                  const t = e.target;
                  return t.getAttribute("p") || t.parentNode.getAttribute("p");
                })(t);
                n && e.userJump(n), e.redraw();
              });
          },
          postpatch: (t, n) => {
            e.vm.autoScrollNow
              ? (Vr(e, n.elm),
                (e.vm.autoScrollNow = !1),
                (e.autoScrollRequested = !1))
              : e.vm.autoScrollRequested &&
                ("" !== e.vm.path && Vr(e, n.elm),
                (e.vm.autoScrollRequested = !1));
          },
        },
      },
      [
        ...(t.ply % 2 == 1 ? [jr(t.ply, !1), Jr()] : []),
        ...Ur(n, t, { parentPath: "", isMainline: !0 }),
      ]
    );
  }
  function ti(e) {
    return d("div.puzzle__moves.areplay", [ei(e)]);
  }
  function ni(e, t, n, o = !1) {
    return d("button.fbt", {
      class: { disabled: n, glowing: o },
      attrs: { "data-act": t, "data-icon": e },
    });
  }
  function oi(e) {
    const t = e.vm.node,
      n = t.children[0],
      o = "play" == e.vm.mode && n && "fail" != n.puzzle;
    return d(
      "div.puzzle__controls.analyse-controls",
      {
        hook: qn((t) => {
          !(function (e, t, n) {
            for (const o of ["touchstart", "mousedown"])
              e.addEventListener(
                o,
                (e) => {
                  t(e), e.preventDefault(), n && n();
                },
                { passive: !1 }
              );
          })(
            t,
            (t) => {
              const n = (function (e) {
                const t = e.target;
                return (
                  t.getAttribute("data-act") ||
                  t.parentNode.getAttribute("data-act")
                );
              })(t);
              "prev" === n
                ? Mn(e)
                : "next" === n
                ? En(e)
                : "first" === n
                ? Pn(e)
                : "last" === n && _n(e);
            },
            e.redraw
          );
        }),
      },
      [
        d("div.jumps", [
          ni("", "first", !t.ply),
          ni("", "prev", !t.ply),
          ni("", "next", !n, o),
          ni("", "last", !n, o),
        ]),
      ]
    );
  }
  let ri = !1;
  function ii(e) {
    if (e.nvui) return e.nvui.render(e);
    const t = e.vm.showComputer(),
      n = e.showEvalGauge();
    return (
      ri !== t && (ri || (e.vm.autoScrollNow = !0), (ri = t)),
      d(
        `main.puzzle.puzzle-${e.getData().replay ? "replay" : "play"}${
          e.streak ? ".puzzle--streak" : ""
        }`,
        {
          class: { "gauge-on": n },
          hook: {
            postpatch(t, o) {
              t.data.gaugeOn !== n &&
                (2 === e.pref.coords &&
                  $("body")
                    .toggleClass("coords-in", n)
                    .toggleClass("coords-out", !n),
                document.body.dispatchEvent(new Event("chessground.resize"))),
                (o.data.gaugeOn = n);
            },
          },
        },
        [
          // d("aside.puzzle__side", [Qn(e), Wn(e), e.streak ? Gn(e) : Hn(e), Yn(e), eo(e)]),
          d("aside.puzzle__side", [Qn(e), eo(e)]), // Alterado por mim
          d(
            "div.puzzle__board.main-board" +
              (e.pref.blindfold ? ".blindfold" : ""),
            {
              hook:
                "ontouchstart" in window ||
                "0" == lichess.storage.get("scrollMoves")
                  ? void 0
                  : ((o = "wheel"),
                    (r = (t) =>
                      (function (e, t) {
                        const n = t.target;
                        if (
                          "PIECE" === n.tagName ||
                          "SQUARE" === n.tagName ||
                          "CG-BOARD" === n.tagName
                        )
                          return (
                            t.preventDefault(),
                            t.deltaY > 0 ? En(e) : t.deltaY < 0 && Mn(e),
                            e.redraw(),
                            !1
                          );
                      })(e, t)),
                    An(o, r, i, !1)),
            },
            [$r(e), e.promotion.view()]
          ),
          Dt(e),
          // d("div.puzzle__tools", [d("div.ceval-wrap", { class: { none: !t } }, t ? [Tt(e), Kt(e)] : []), ti(e), Fr(e)]),
          d("div.puzzle__tools", [ti(e), Fr(e)]),
          oi(e),
          // si(e), Alterado por mim
        ]
      )
    );
    var o, r, i;
  }
  function si(e) {
    var t;
    const n = e.session.get().rounds,
      o = e.getData().puzzle.id;
    return d("div.puzzle__session", [
      ...n.map((t) => {
        const n =
          t.ratingDiff && e.showRatings
            ? t.ratingDiff > 0
              ? "+" + t.ratingDiff
              : t.ratingDiff
            : null;
        return d(
          `a.result-${t.result}${n ? "" : ".result-empty"}`,
          {
            key: t.id,
            class: { current: o == t.id },
            attrs: {
              href: `/training/${e.session.theme}/${t.id}`,
              ...(e.streak ? { target: "_blank", rel: "noopener" } : {}),
            },
          },
          n
        );
      }),
      n.find((e) => e.id == o)
        ? e.streak
          ? null
          : d("a.session-new", {
              key: "new",
              attrs: { href: `/training/${e.session.theme}` },
            })
        : d(
            "a.result-cursor.current",
            {
              key: o,
              attrs: e.streak
                ? {}
                : { href: `/training/${e.session.theme}/${o}` },
            },
            null === (t = e.streak) || void 0 === t ? void 0 : t.data.index
          ),
    ]);
  }
  const ai = (function (u, d) {
    let h, p;
    const f = {
        create: [],
        update: [],
        remove: [],
        destroy: [],
        pre: [],
        post: [],
      },
      m = void 0 !== d ? d : e;
    for (h = 0; h < l.length; ++h)
      for (f[l[h]] = [], p = 0; p < u.length; ++p) {
        const e = u[p][l[h]];
        void 0 !== e && f[l[h]].push(e);
      }
    function v(e) {
      const n = e.id ? "#" + e.id : "",
        o = e.getAttribute("class"),
        r = o ? "." + o.split(" ").join(".") : "";
      return t(m.tagName(e).toLowerCase() + n + r, {}, [], void 0, e);
    }
    function g(e, t) {
      return function () {
        if (0 == --t) {
          const t = m.parentNode(e);
          m.removeChild(t, e);
        }
      };
    }
    function b(e, t) {
      var a, c;
      let l,
        u = e.data;
      if (void 0 !== u) {
        const t = null === (a = u.hook) || void 0 === a ? void 0 : a.init;
        i(t) && (t(e), (u = e.data));
      }
      const d = e.children,
        h = e.sel;
      if ("!" === h)
        r(e.text) && (e.text = ""), (e.elm = m.createComment(e.text));
      else if (void 0 !== h) {
        const r = h.indexOf("#"),
          a = h.indexOf(".", r),
          p = r > 0 ? r : h.length,
          v = a > 0 ? a : h.length,
          g = -1 !== r || -1 !== a ? h.slice(0, Math.min(p, v)) : h,
          k = (e.elm =
            i(u) && i((l = u.ns))
              ? m.createElementNS(l, g, u)
              : m.createElement(g, u));
        for (
          p < v && k.setAttribute("id", h.slice(p + 1, v)),
            a > 0 &&
              k.setAttribute("class", h.slice(v + 1).replace(/\./g, " ")),
            l = 0;
          l < f.create.length;
          ++l
        )
          f.create[l](s, e);
        if (n(d))
          for (l = 0; l < d.length; ++l) {
            const e = d[l];
            null != e && m.appendChild(k, b(e, t));
          }
        else o(e.text) && m.appendChild(k, m.createTextNode(e.text));
        const w = e.data.hook;
        i(w) &&
          (null === (c = w.create) || void 0 === c || c.call(w, s, e),
          w.insert && t.push(e));
      } else e.elm = m.createTextNode(e.text);
      return e.elm;
    }
    function k(e, t, n, o, r, i) {
      for (; o <= r; ++o) {
        const r = n[o];
        null != r && m.insertBefore(e, b(r, i), t);
      }
    }
    function w(e) {
      var t, n;
      const o = e.data;
      if (void 0 !== o) {
        null ===
          (n =
            null === (t = null == o ? void 0 : o.hook) || void 0 === t
              ? void 0
              : t.destroy) ||
          void 0 === n ||
          n.call(t, e);
        for (let t = 0; t < f.destroy.length; ++t) f.destroy[t](e);
        if (void 0 !== e.children)
          for (let t = 0; t < e.children.length; ++t) {
            const n = e.children[t];
            null != n && "string" != typeof n && w(n);
          }
      }
    }
    function y(e, t, n, o) {
      for (var r, s; n <= o; ++n) {
        let o, a;
        const c = t[n];
        if (null != c)
          if (i(c.sel)) {
            w(c), (o = f.remove.length + 1), (a = g(c.elm, o));
            for (let t = 0; t < f.remove.length; ++t) f.remove[t](c, a);
            const e =
              null ===
                (s =
                  null === (r = null == c ? void 0 : c.data) || void 0 === r
                    ? void 0
                    : r.hook) || void 0 === s
                ? void 0
                : s.remove;
            i(e) ? e(c, a) : a();
          } else m.removeChild(e, c.elm);
      }
    }
    function z(e, t, n) {
      var o, s, l, u, d;
      const h = null === (o = t.data) || void 0 === o ? void 0 : o.hook;
      null === (s = null == h ? void 0 : h.prepatch) ||
        void 0 === s ||
        s.call(h, e, t);
      const p = (t.elm = e.elm),
        v = e.children,
        g = t.children;
      if (e !== t) {
        if (void 0 !== t.data) {
          for (let n = 0; n < f.update.length; ++n) f.update[n](e, t);
          null ===
            (u =
              null === (l = t.data.hook) || void 0 === l ? void 0 : l.update) ||
            void 0 === u ||
            u.call(l, e, t);
        }
        r(t.text)
          ? i(v) && i(g)
            ? v !== g &&
              (function (e, t, n, o) {
                let i,
                  s,
                  l,
                  u,
                  d = 0,
                  h = 0,
                  p = t.length - 1,
                  f = t[0],
                  v = t[p],
                  g = n.length - 1,
                  w = n[0],
                  S = n[g];
                for (; d <= p && h <= g; )
                  null == f
                    ? (f = t[++d])
                    : null == v
                    ? (v = t[--p])
                    : null == w
                    ? (w = n[++h])
                    : null == S
                    ? (S = n[--g])
                    : a(f, w)
                    ? (z(f, w, o), (f = t[++d]), (w = n[++h]))
                    : a(v, S)
                    ? (z(v, S, o), (v = t[--p]), (S = n[--g]))
                    : a(f, S)
                    ? (z(f, S, o),
                      m.insertBefore(e, f.elm, m.nextSibling(v.elm)),
                      (f = t[++d]),
                      (S = n[--g]))
                    : a(v, w)
                    ? (z(v, w, o),
                      m.insertBefore(e, v.elm, f.elm),
                      (v = t[--p]),
                      (w = n[++h]))
                    : (void 0 === i && (i = c(t, d, p)),
                      (s = i[w.key]),
                      r(s)
                        ? m.insertBefore(e, b(w, o), f.elm)
                        : ((l = t[s]),
                          l.sel !== w.sel
                            ? m.insertBefore(e, b(w, o), f.elm)
                            : (z(l, w, o),
                              (t[s] = void 0),
                              m.insertBefore(e, l.elm, f.elm))),
                      (w = n[++h]));
                (d <= p || h <= g) &&
                  (d > p
                    ? ((u = null == n[g + 1] ? null : n[g + 1].elm),
                      k(e, u, n, h, g, o))
                    : y(e, t, d, p));
              })(p, v, g, n)
            : i(g)
            ? (i(e.text) && m.setTextContent(p, ""),
              k(p, null, g, 0, g.length - 1, n))
            : i(v)
            ? y(p, v, 0, v.length - 1)
            : i(e.text) && m.setTextContent(p, "")
          : e.text !== t.text &&
            (i(v) && y(p, v, 0, v.length - 1), m.setTextContent(p, t.text)),
          null === (d = null == h ? void 0 : h.postpatch) ||
            void 0 === d ||
            d.call(h, e, t);
      }
    }
    return function (e, t) {
      let n, o, r;
      const i = [];
      for (n = 0; n < f.pre.length; ++n) f.pre[n]();
      for (
        (function (e) {
          return void 0 !== e.sel;
        })(e) || (e = v(e)),
          a(e, t)
            ? z(e, t, i)
            : ((o = e.elm),
              (r = m.parentNode(o)),
              b(t, i),
              null !== r &&
                (m.insertBefore(r, t.elm, m.nextSibling(o)), y(r, [e], 0, 0))),
          n = 0;
        n < i.length;
        ++n
      )
        i[n].data.hook.insert(i[n]);
      for (n = 0; n < f.post.length; ++n) f.post[n]();
      return t;
    };
  })([m, p]);
  return (
    (window.Chessground = Dr),
    function (e) {
      const t = document.querySelector("main.puzzle"),
        n = Kn(e, function () {
          r = ai(r, ii(n));
        }),
        o = ii(n);
      t.innerHTML = "";
      let r = ai(t, o);
      !(function () {
        if ("ontouchstart" in window) return;
        let e, t;
        const n = (n) => {
          (e = n.pageX), (t = n.pageY);
        };
        let o = {};
        $("#topnav.hover").each(function () {
          const r = $(this).removeClass("hover"),
            i = () => r.toggleClass("hover"),
            s = () => {
              Math.sqrt((o.pX - e) * (o.pX - e) + (o.pY - t) * (o.pY - t)) < 8
                ? (r.off(o.event, n),
                  delete o.timeoutId,
                  (o.isActive = !0),
                  i())
                : ((o.pX = e), (o.pY = t), (o.timeoutId = setTimeout(s, 200)));
            },
            a = function (e) {
              o.timeoutId && (o.timeoutId = clearTimeout(o.timeoutId));
              const t = (o.event = "mousemove");
              if ("mouseover" == e.type) {
                if (o.isActive || e.buttons) return;
                (o.pX = e.pageX),
                  (o.pY = e.pageY),
                  r.off(t, n).on(t, n),
                  (o.timeoutId = setTimeout(s, 200));
              } else {
                if (!o.isActive) return;
                r.off(t, n), (o = {}), i();
              }
            };
          r.on("mouseover", a).on("mouseleave", a);
        });
      })();
    }
  );
})();
